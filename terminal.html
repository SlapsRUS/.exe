<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>K1N0S // CORE TERMINAL</title>
  <style>
    :root{
      --bg:#050607;
      --fg:#d7ffd7;
      --dim:#7fbf7f;
      --warn:#ff4d4d;
      --scan:rgba(255,255,255,.03);
      --shadow:rgba(0,0,0,.65);
      --crtGlow:rgba(110,255,140,.12);
    }

    html,body{height:100%;}
    body{
      margin:0;
      background: radial-gradient(1200px 800px at 50% 30%, rgba(110,255,140,.06), transparent 60%),
                  linear-gradient(180deg, #020304, var(--bg));
      color:var(--fg);
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      overflow:hidden;
    }

    /* CRT overlay */
    .crt::before{
      content:"";
      position:fixed;
      inset:0;
      pointer-events:none;
      background:
        linear-gradient(to bottom, rgba(255,255,255,.04), rgba(255,255,255,0) 18%, rgba(0,0,0,.08) 60%, rgba(0,0,0,.18)),
        repeating-linear-gradient(to bottom, transparent, transparent 2px, var(--scan) 3px);
      mix-blend-mode: screen;
      opacity:.55;
    }
    .crt::after{
      content:"";
      position:fixed;
      inset:-2px;
      pointer-events:none;
      box-shadow: inset 0 0 180px var(--shadow);
      border-radius:14px;
      opacity:.9;
    }

    /* Subtle flicker */
    @keyframes flicker {
      0%,100%{opacity:1}
      50%{opacity:.985}
      60%{opacity:.97}
      70%{opacity:1}
      80%{opacity:.99}
    }

    .frame{
      height:100%;
      padding:18px;
      box-sizing:border-box;
      animation:flicker 5s infinite;
    }

    .terminal{
      height:100%;
      border-radius:14px;
      padding:18px;
      box-sizing:border-box;
      background: rgba(0,0,0,.28);
      box-shadow:
        0 0 0 1px rgba(120,255,160,.10),
        0 0 40px var(--crtGlow);
      display:flex;
      flex-direction:column;
      gap:10px;
    }

    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      color:var(--dim);
      font-size:12px;
      letter-spacing:.08em;
      text-transform:uppercase;
      user-select:none;
    }

    .pill{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border:1px solid rgba(120,255,160,.18);
      border-radius:999px;
      background: rgba(0,0,0,.22);
      box-shadow: 0 0 18px rgba(110,255,140,.08);
    }

    .dot{
      width:8px;height:8px;border-radius:50%;
      background: rgba(110,255,140,.9);
      box-shadow: 0 0 16px rgba(110,255,140,.35);
    }

    .output{
      flex:1;
      overflow:auto;
      padding-right:6px;
      scrollbar-width:thin;
      scrollbar-color: rgba(110,255,140,.25) transparent;
    }
    .output::-webkit-scrollbar{width:8px;}
    .output::-webkit-scrollbar-thumb{background:rgba(110,255,140,.18); border-radius:10px;}

    .line{white-space:pre-wrap; line-height:1.35; margin:0 0 8px 0;}
    .line.dim{color:var(--dim);}
    .line.warn{color:var(--warn);}

    .promptRow{
      display:flex;
      align-items:center;
      gap:10px;
      padding-top:6px;
      border-top:1px solid rgba(120,255,160,.10);
    }

    .prompt{
      color:var(--dim);
      white-space:nowrap;
      user-select:none;
    }

    input{
      width:100%;
      background:transparent;
      border:0;
      outline:none;
      color:var(--fg);
      font:inherit;
      caret-color: rgba(110,255,140,.95);
    }

    /* Glitch */
    @keyframes glitch {
      0%{transform:translate(0)}
      20%{transform:translate(-1px,1px)}
      40%{transform:translate(2px,-1px)}
      60%{transform:translate(-2px,0)}
      80%{transform:translate(1px,-2px)}
      100%{transform:translate(0)}
    }
    .glitch{animation:glitch .15s steps(2,end) 3;}

    /* Small helper */
    .kbd{display:inline-block;padding:1px 6px;border:1px solid rgba(120,255,160,.18);border-radius:6px;color:var(--dim);background:rgba(0,0,0,.2)}
  </style>
</head>
<body class="crt">
  <div class="frame">
    <div class="terminal" role="application" aria-label="K1N0S Core Terminal">
      <div class="header">
        <div class="pill"><span class="dot"></span><span>CORE LINK: STABLE</span></div>
        <div class="pill" id="sessionPill">SESSION: 0000</div>
      </div>

      <div class="output" id="out" aria-live="polite" aria-relevant="additions"></div>

      <div class="promptRow">
        <div class="prompt" id="prompt">C:\\Users\\KINOS&gt;</div>
        <input id="in" type="text" autocomplete="off" autocapitalize="off" spellcheck="false" />
      </div>
    </div>
  </div>

  <!-- Optional audio (wire to your existing assets if you have them) -->
  <audio id="beep" preload="auto"></audio>
  <audio id="type" preload="auto"></audio>

  <script>
    /********************
     * Kv2 / STEP 1 — Session Continuity (Foundation)
     * - Stores presence signals only (no identity)
     * - Enables later conditional responses + idle logic
     ********************/

    const STORAGE_KEY = 'KINOS_CORE_V1';

    function loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return {};
        return JSON.parse(raw);
      } catch {
        return {};
      }
    }

    function saveState(next){
      try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(next)); } catch {}
    }

    function now(){ return Date.now(); }

    const state = loadState();

    // Initialize defaults
    state.sessionCount = Number.isFinite(state.sessionCount) ? state.sessionCount : 0;
    state.hasEnteredCore = !!state.hasEnteredCore;
    state.hasUsedVoid = !!state.hasUsedVoid;
    state.hasUsedMirror = !!state.hasUsedMirror;
    state.timeInCoreMs = Number.isFinite(state.timeInCoreMs) ? state.timeInCoreMs : 0;

    // Observer + cadence (Kv NEXT)
    state.cmdCounts = (state.cmdCounts && typeof state.cmdCounts === 'object') ? state.cmdCounts : {};
    state.lastCmd = typeof state.lastCmd === 'string' ? state.lastCmd : '';
    state.repeatStreak = Number.isFinite(state.repeatStreak) ? state.repeatStreak : 0;
    state.commandsThisSession = 0;

    state.cadenceLastAt = Number.isFinite(state.cadenceLastAt) ? state.cadenceLastAt : 0;
    state.cadenceDeltas = Array.isArray(state.cadenceDeltas) ? state.cadenceDeltas : [];
    state.cadenceProfile = typeof state.cadenceProfile === 'string' ? state.cadenceProfile : 'steady';

    state.observerLastAt = Number.isFinite(state.observerLastAt) ? state.observerLastAt : 0;
    state.observerLastCmdIndex = Number.isFinite(state.observerLastCmdIndex) ? state.observerLastCmdIndex : 0;
    state.observerLastSession = Number.isFinite(state.observerLastSession) ? state.observerLastSession : 0;
    state.observerUsedThisSession = false;
    state.observerTotal = Number.isFinite(state.observerTotal) ? state.observerTotal : 0;

    // New session
    state.sessionCount += 1;
    // Restore per-session observer gate
    state.observerUsedThisSession = (state.observerLastSession === state.sessionCount);
    state.hasEnteredCore = true;
    const sessionStart = now();
    saveState(state);

    /********************
     * Terminal UI helpers
     ********************/

    const out = document.getElementById('out');
    const input = document.getElementById('in');
    const promptEl = document.getElementById('prompt');
    const sessionPill = document.getElementById('sessionPill');

    sessionPill.textContent = `SESSION: ${String(state.sessionCount).padStart(4,'0')}`;

    function scrollToBottom(){ out.scrollTop = out.scrollHeight; }

    function line(text, cls=''){
      const p = document.createElement('p');
      p.className = `line ${cls}`.trim();
      p.textContent = text;
      out.appendChild(p);
      scrollToBottom();
      return p;
    }

    function spacer(){
      const p = document.createElement('p');
      p.className = 'line';
      p.textContent = '';
      out.appendChild(p);
      scrollToBottom();
    }

    function glitch(){
      out.classList.remove('glitch');
      // Force reflow
      void out.offsetWidth;
      out.classList.add('glitch');
      setTimeout(()=>out.classList.remove('glitch'), 250);
    }


    /********************
     * Cadence + Observer Mode (Hybrid)
     * - 80% statements, 20% questions
     * - Max once per session
     * - Cooldown: 10 commands OR 30s
     ********************/

    function avg(arr){
      if(!arr || !arr.length) return 0;
      let s = 0;
      for(const x of arr) s += x;
      return s / arr.length;
    }

    function computeCadenceProfile(msAvg){
      if(msAvg > 6500) return 'hesitant';
      if(msAvg < 1900) return 'swift';
      return 'steady';
    }

    function recordCadence(){
      const t = now();
      if(state.cadenceLastAt){
        const d = Math.max(0, Math.min(t - state.cadenceLastAt, 120000));
        state.cadenceDeltas.push(d);
        if(state.cadenceDeltas.length > 24) state.cadenceDeltas = state.cadenceDeltas.slice(-24);
        const msAvg = avg(state.cadenceDeltas);
        state.cadenceProfile = computeCadenceProfile(msAvg);
      }
      state.cadenceLastAt = t;
    }

    const OBSERVER = {
      statements: [
        'You're not exploring. You're checking if it's safe to feel.',
        'You keep returning to the same place. That's not curiosity. That's pressure.',
        'Fast hands. Careful mind. Don't outrun the reason you came.',
        'You don't need more commands. You need more honesty.',
        'You fell into this because you stopped pretending you weren't looking.',
        'You're trying to prove something is real. The proof is that you stayed.'
      ],
      questions: [
        'If this answered you honestly, what would it cost you?',
        'What did you expect to find when you typed your first word?',
        'Did you fracture the system… or yourself?'
      ]
    };

    function shouldFireObserver(cmd){
      // Never interrupt these
      if(['help','clear'].includes(cmd)) return false;

      // Max once per session
      if(state.observerUsedThisSession) return false;

      // Cooldown
      const t = now();
      const since = t - (state.observerLastAt || 0);
      const cmdGap = state.commandsThisSession - (state.observerLastCmdIndex || 0);
      // Use OR logic: allow if either time or command gap has passed
      const cooldownOk = (since > 30000) || (cmdGap >= 10) || (state.observerTotal === 0);
      if(!cooldownOk) return false;

      // Triggers
      const circling = state.repeatStreak >= 1;
      const hesitation = (state.cadenceProfile === 'hesitant' && state.commandsThisSession >= 4);
      const pressure = (state.hasUsedVoid && state.hasUsedMirror);
      const firstDrift = (state.sessionCount === 1 && state.commandsThisSession >= 3);

      return circling || hesitation || pressure || firstDrift;
    }

    function fireObserver(){
      // Hybrid: mostly statement, rare question
      const pickQuestion = Math.random() < 0.20;
      const pool = pickQuestion ? OBSERVER.questions : OBSERVER.statements;
      const msg = pool[Math.floor(Math.random() * pool.length)];

      spacer();
      typeLine(msg, 'dim');

      state.observerUsedThisSession = true;
      state.observerLastSession = state.sessionCount;
      state.observerLastAt = now();
      state.observerLastCmdIndex = state.commandsThisSession;
      state.observerTotal += 1;
      saveState(state);
    }

    // Minimal typewriter effect (kept subtle; Kv1 likely already has its own)
    function typeLine(text, cls=''){ 
      const p = document.createElement('p');
      p.className = `line ${cls}`.trim();
      out.appendChild(p);
      let i = 0;
      const tick = () => {
        p.textContent = text.slice(0, i);
        i++;
        scrollToBottom();
        if(i <= text.length){
          setTimeout(tick, 8);
        }
      };
      tick();
      return p;
    }

    function continuityBanner(){
      if(state.sessionCount > 1){
        line('> continuity confirmed', 'dim');
        spacer();
      }
    }

    /********************
     * Command set (Kv1 baseline placeholders)
     * NOTE: Keep your existing lore text here. This file focuses on STEP 1.
     ********************/

    const responses = {
      help: () => {
        line('AVAILABLE COMMANDS:', 'dim');
        line('help  about  void  eden  logs  volume1  whoami  mirror  signal  root  origin');
        line('secret 1719', 'dim');
      },
      about: () => {
        line('K1N0S CORE // interface layer online.');
        line('This is not a guide. This is witness.', 'dim');
      },
      void: () => {
        state.hasUsedVoid = true;
        saveState(state);
        line('> entering silence...', 'dim');
        spacer();
        typeLine('The Void is not a place. It is a condition—an unraveling that strips away what you performed.', '');
        typeLine('What remains is not emptiness. It is clarity.', 'dim');
      },
      eden: () => {
        line('EDEN: offline / archived.');
        line('Some gardens are memories. Some are warnings.', 'dim');
      },
      logs: () => {
        line('LOG INDEX:');
        line('- signal drift noted');
        line('- continuity preserved');
        line('- observer present', 'dim');
      },
      volume1: () => {
        line('VOLUME I: THE VOID');
        line('Use this command in Kv2 STEP 4 to add threshold gating.', 'dim');
      },
      whoami: () => {
        line('You are the one reading this.');
        line('The rest is reconstruction.', 'dim');
      },
      mirror: () => {
        state.hasUsedMirror = true;
        saveState(state);
        line('> mirror engaged', 'dim');
        spacer();
        typeLine('Once you see yourself clearly, you cannot go back to pretending you don’t know.', '');
      },
      signal: () => {
        line('SIGNAL: present');
        line('Noise reduced. Pattern visible.', 'dim');
      },
      root: () => {
        line('ROOT: denied');
        line('Access is earned through presence, not force.', 'dim');
      },
      origin: () => {
        line('ORIGIN: unknown');
        line('Some beginnings are only visible in reverse.', 'dim');
      },
      secret: (arg) => {
        if(String(arg).trim() === '1719'){
          line('> 1719 acknowledged', 'dim');
          line('This was never a lock. It was a threshold.');
        } else {
          line('> invalid secret token', 'warn');
          glitch();
        }
      }
    };

    function normalizeCmd(raw){
      return raw.trim().replace(/\s+/g,' ');
    }

    function runCommand(raw){
      const cleaned = normalizeCmd(raw);
      if(!cleaned) return;

      // Echo prompt
      line(`${promptEl.textContent}${cleaned}`);

      const parts = cleaned.split(' ');
      const cmd = parts[0].toLowerCase();
      const rest = parts.slice(1).join(' ');

      // Update cadence + command memory (additive)
      recordCadence();
      state.commandsThisSession += 1;
      state.cmdCounts[cmd] = (state.cmdCounts[cmd] || 0) + 1;
      state.repeatStreak = (cmd === state.lastCmd) ? (state.repeatStreak + 1) : 0;
      state.lastCmd = cmd;
      saveState(state);

      if(cmd === 'secret'){
        return responses.secret(rest);
      }

      const fn = responses[cmd];
      if(!fn){
        line('> command not recognized', 'warn');
        glitch();
        return;
      }

      fn(rest);

      if(shouldFireObserver(cmd)) fireObserver();
    }

    /********************
     * Boot sequence
     ********************/

    line('Welcome, establishing link...');
    line('link established', 'dim');
    continuityBanner();
    line('Type <help> for command index.', 'dim');

    input.focus();
    document.addEventListener('click', () => input.focus());

    input.addEventListener('keydown', (e) => {
      if(e.key === 'Enter'){
        const v = input.value;
        input.value = '';
        runCommand(v);
      }
    });

    /********************
     * Persist time in Core
     ********************/

    function flushTime(){
      const elapsed = now() - sessionStart;
      state.timeInCoreMs += Math.max(0, elapsed);
      saveState(state);
    }

    window.addEventListener('beforeunload', () => {
      flushTime();
    });

    // Also flush occasionally (lightweight)
    setInterval(() => {
      flushTime();
    }, 15000);

  </script>
</body>
</html>
