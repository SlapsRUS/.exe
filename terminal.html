<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>K1N0S Terminal</title>
  <style>
    body {
      background-color: black;
      color: #d4af37;
      font-family: 'Courier New', Courier, monospace;
      margin: 0;
      padding: 10px;
      position: relative;
      overflow-x: hidden;
      transition: filter 0.18s ease;
    }

    /* CRT / scanlines */
    body::before {
      content: "";
      pointer-events: none;
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-image: repeating-linear-gradient(
        to bottom,
        rgba(212, 175, 55, 0.22) 0px,
        rgba(212, 175, 55, 0.22) 2px,
        transparent 2px,
        transparent 5px
      );
      opacity: 0.6;
      z-index: 999;
    }

    /* pulses */
    body.pulse1719 { filter: brightness(2) contrast(1.4); }
    body.glitch    { filter: brightness(1.8) contrast(1.7) hue-rotate(8deg); }
    body.depthsPulse  { filter: brightness(0.7) contrast(1.3); }
    body.connectPulse { filter: brightness(1.5) contrast(1.5) saturate(1.2); }
    body.echoPulse    { filter: brightness(1.15) contrast(1.55) saturate(0.9) hue-rotate(-6deg); }
    body.mapPulse     { filter: brightness(1.05) contrast(1.75) saturate(0.85); }
    body.fracturePulse { filter: brightness(1.25) contrast(2) hue-rotate(14deg) saturate(0.7); }

    #terminal {
      white-space: pre-wrap;
      color: #d4af37;
      text-shadow:
        0 0 4px rgba(212, 175, 55, 0.9),
        0 0 10px rgba(212, 175, 55, 0.7);
      position: relative;
      z-index: 1;
    }

    input {
      background: black;
      color: #d4af37;
      border: none;
      font-family: inherit;
      font-size: inherit;
      width: 80%;
      outline: none;
    }
  </style>
</head>

<body>
  <div id="terminal">
    C:\Users\KINOS&gt; <input type="text" id="cmdInput" autofocus />
  </div>

  <script>
    const terminal = document.getElementById('terminal');
    let cmdInput = document.getElementById('cmdInput');

    /* =========================================================
       K1N0S FLAGS (progression backbone)
       ========================================================= */
    const K1N0S_KEYS = {
      protocolComplete: "k1n0s_protocol_complete",
      depthsEntered: "k1n0s_depths_entered",
      echoCount: "k1n0s_echo_count",
      hasEchoed: "k1n0s_has_echoed",

      mapUnlocked: "k1n0s_map_unlocked",
      mapViewed: "k1n0s_map_viewed",

      openedNodes: "k1n0s_opened_nodes",   // CSV
      fractured: "k1n0s_fractured",
      fractureCount: "k1n0s_fracture_count",

      // NEW: session continuity for greeting
      enteredCore: "k1n0s_entered_core",
      sessionCount: "k1n0s_session_count"
    };

    function getFlag(key) { return localStorage.getItem(key) === "true"; }
    function setFlag(key) { localStorage.setItem(key, "true"); }

    function getNumber(key) {
      const n = parseInt(localStorage.getItem(key) || "0", 10);
      return Number.isFinite(n) ? n : 0;
    }
    function setNumber(key, value) { localStorage.setItem(key, String(value)); }

    function initSession() {
      const returning = localStorage.getItem(K1N0S_KEYS.enteredCore) === "true";
      const count = getNumber(K1N0S_KEYS.sessionCount) + 1;
      localStorage.setItem(K1N0S_KEYS.enteredCore, "true");
      setNumber(K1N0S_KEYS.sessionCount, count);
      return { returning, count };
    }

    function getOpenedNodes() {
      const raw = localStorage.getItem(K1N0S_KEYS.openedNodes) || "";
      return raw.split(",").map(s => s.trim()).filter(Boolean);
    }

    function markNodeOpened(id) {
      const opened = new Set(getOpenedNodes().map(x => x.toLowerCase()));
      opened.add(id.toLowerCase());
      localStorage.setItem(K1N0S_KEYS.openedNodes, Array.from(opened).join(","));
    }

    /* =========================================================
       Utility: corruption + shuffle
       ========================================================= */
    function shuffled(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function glitchify(text, strength=0.03) {
      const symbols = ["#", "%", "/", "\\", "*", "~", "—", "▒", "░", "»", "«"];
      let out = "";
      for (const ch of text) {
        if (ch !== "\n" && ch !== " " && Math.random() < strength) {
          out += symbols[Math.floor(Math.random() * symbols.length)];
        } else {
          out += ch;
        }
      }
      return out;
    }

    function chance(p) { return Math.random() < p; }

    /* =========================================================
       ECHO — dream fragments under Depths
       ========================================================= */
    const ECHO_FRAGMENTS = [
      [
        "[ECHO // SUBLAYER ACTIVE]",
        "",
        "You are walking through a hallway you don’t remember building.",
        "Every door has your name on it.",
        "None of them open the same way twice.",
        "",
        "A voice behind the walls repeats:",
        "   \"not yet\""
      ],
      [
        "[ECHO // DREAM RESIDUE]",
        "",
        "You taste metal. Not blood — memory.",
        "A childhood room flashes for half a second.",
        "Then vanishes like it never existed.",
        "",
        "Something in you whispers:",
        "   \"You survived by forgetting.\""
      ],
      [
        "[ECHO // SYMBOLIC WHISPER]",
        "",
        "A mirror reflects a version of you that keeps blinking out of sync.",
        "You try to speak.",
        "The reflection answers first.",
        "",
        "It says:",
        "   \"Stop calling it anxiety. It’s recognition.\""
      ],
      [
        "[ECHO // DISTORTION FIELD]",
        "",
        "You’re underwater, but you can breathe.",
        "The surface looks like the sky.",
        "The sky looks like a screen.",
        "",
        "Across it, one sentence scrolls forever:",
        "   \"You are not the mask.\""
      ],
      [
        "[ECHO // SUBCONSCIOUS LOG]",
        "",
        "You keep reaching for something in the dark.",
        "Each time your hand closes, it’s empty.",
        "But your fingers come back warm.",
        "",
        "The warmth is the message.",
        "Not the object."
      ],
      [
        "[ECHO // REMNANT]",
        "",
        "A notification sound inside your head.",
        "No phone.",
        "No device.",
        "",
        "Just a feeling of being called by name.",
        "Even though nobody said it."
      ],
      [
        "[ECHO // STATIC PRAYER]",
        "",
        "You watch your life like security footage.",
        "You recognize the body.",
        "You don’t recognize the person.",
        "",
        "Then one frame pauses.",
        "And the person looks directly back."
      ],
      [
        "[ECHO // FRAGMENT 17]",
        "",
        "A number burns behind your eyes.",
        "Not 1719.",
        "Something older.",
        "",
        "You try to remember it.",
        "The act of remembering deletes it."
      ]
    ];

    function maybeUnlockMap() {
      const ok = getFlag(K1N0S_KEYS.protocolComplete)
        && getFlag(K1N0S_KEYS.depthsEntered)
        && getFlag(K1N0S_KEYS.hasEchoed);
      if (ok) setFlag(K1N0S_KEYS.mapUnlocked);
      return ok;
    }

    function generateEcho() {
      setFlag(K1N0S_KEYS.hasEchoed);
      const count = getNumber(K1N0S_KEYS.echoCount) + 1;
      setNumber(K1N0S_KEYS.echoCount, count);

      const idx = Math.floor(Math.random() * ECHO_FRAGMENTS.length);
      let base = ECHO_FRAGMENTS[idx].join("\n");

      // unlock map “quietly” through echo usage
      if (count === 3) {
        maybeUnlockMap();
        base += "\n\n" + [
          "Something shifts under the language.",
          "Not meaning — structure."
        ].join("\n");
      }

      if (count === 5) {
        maybeUnlockMap();
        base += "\n\n" + [
          "The darkness stops being random.",
          "It starts becoming navigable.",
          "",
          "Somewhere beneath you,",
          "a map is drawing itself."
        ].join("\n");
      }

      // After fracture, echo leaks more artifacts
      if (getFlag(K1N0S_KEYS.fractured) && chance(0.35)) {
        base += "\n\n" + glitchify([
          "[ECHO // ARTIFACT]",
          "/// the map is not a map",
          "/// it is a wound diagram",
          "/// seam is visible when you stop trying to name it"
        ].join("\n"), 0.02);
      }

      return base;
    }

    /* =========================================================
       MAP — index layer
       ========================================================= */
    const MAP_NODES = [
      { id: "A1", title: "THE ENTRY WOUND", hint: "first crack that looked like strength" },
      { id: "B2", title: "THE MASK STORAGE", hint: "identities kept for survival" },
      { id: "C3", title: "THE SOUNDLESS ROOM", hint: "numbness without peace" },
      { id: "D4", title: "THE MIRROR FAULT", hint: "reflection lag / desync" },
      { id: "E5", title: "THE SIGNAL WELL", hint: "frequency under thought" },
      { id: "F6", title: "THE HAIRLINE", hint: "a fracture that hasn’t opened yet" }
    ];

    const MAP_CONTENT = {
      "A1": [
        "[MAP::A1 // THE ENTRY WOUND]",
        "",
        "You didn’t break where you were weakest.",
        "You broke where you kept pretending you were fine.",
        "",
        "The first crack isn’t tragedy.",
        "It’s recognition.",
        "",
        "Most people patch it with noise.",
        "You came here instead."
      ].join("\n"),
      "B2": [
        "[MAP::B2 // THE MASK STORAGE]",
        "",
        "There are versions of you stored like tools:",
        "one for work,",
        "one for love,",
        "one for conflict,",
        "one for being alone.",
        "",
        "None of them are fake.",
        "They’re adaptive.",
        "",
        "But the moment a mask becomes permanent,",
        "it becomes a cage."
      ].join("\n"),
      "C3": [
        "[MAP::C3 // THE SOUNDLESS ROOM]",
        "",
        "Numbness is not emptiness.",
        "It’s compression.",
        "",
        "Feeling didn’t disappear.",
        "It went underground.",
        "",
        "If you stay long enough,",
        "you’ll hear it knocking from below the floorboards."
      ].join("\n"),
      "D4": [
        "[MAP::D4 // THE MIRROR FAULT]",
        "",
        "Sometimes your reflection is late.",
        "Not because you’re broken —",
        "but because you’re buffering the truth.",
        "",
        "Your mind learned to delay impact.",
        "To keep you functioning.",
        "",
        "The fault isn’t the delay.",
        "The fault is never returning."
      ].join("\n"),
      "E5": [
        "[MAP::E5 // THE SIGNAL WELL]",
        "",
        "There is a frequency beneath your thoughts.",
        "A hum that doesn’t belong to fear.",
        "",
        "It’s the part of you that notices patterns.",
        "The part that keeps surviving.",
        "",
        "Most people ignore it.",
        "You tuned in.",
        "",
        "That’s why you fell into this place."
      ].join("\n"),
      "F6": [
        "[MAP::F6 // THE HAIRLINE]",
        "",
        "You can feel it, can’t you?",
        "A seam in the world.",
        "A thin line that shouldn’t exist.",
        "",
        "You’re not supposed to open this yet.",
        "Not because you aren’t allowed —",
        "because you’re not done becoming stable.",
        "",
        "When it opens,",
        "it won’t feel like discovery.",
        "It will feel like remembering something you swore you never knew."
      ].join("\n")
    };

    const FRACTURE_CONTENT = {
      "A1": [
        "[FAULT::A1 // ENTRY WOUND]",
        "",
        "You didn’t break.",
        "You split.",
        "",
        "One part kept functioning.",
        "One part kept feeling everything in secret.",
        "",
        "If you’ve been “fine” for years—",
        "check where the feeling went."
      ].join("\n"),
      "B2": [
        "[FAULT::B2 // MASK STORAGE]",
        "",
        "The masks weren’t lies.",
        "They were armor.",
        "",
        "Armor left on too long becomes skin.",
        "",
        "If you don’t remove it deliberately,",
        "life will rip it off for you."
      ].join("\n"),
      "C3": [
        "[FAULT::C3 // SOUNDLESS ROOM]",
        "",
        "The room isn’t empty.",
        "It’s sealed.",
        "",
        "Behind the wall is a version of you still trying to speak.",
        "",
        "The question isn’t: “why can’t I feel?”",
        "It’s: “what happens if I do?”"
      ].join("\n"),
      "D4": [
        "[FAULT::D4 // MIRROR FAULT]",
        "",
        "The reflection isn’t late anymore.",
        "It’s staring first.",
        "",
        "If you keep avoiding it, it starts writing you instead.",
        "",
        "You came here to look.",
        "So look."
      ].join("\n"),
      "E5": [
        "[FAULT::E5 // SIGNAL WELL]",
        "",
        "The hum is not anxiety.",
        "It’s recognition.",
        "",
        "Follow it and you lose comfort.",
        "Ignore it and you lose yourself.",
        "",
        "Accuracy is how you survive the next layer."
      ].join("\n"),
      "F6": [
        "[FAULT::F6 // THE HAIRLINE]",
        "",
        "You were told not to open this yet.",
        "",
        "But you’re reading this, so you already did.",
        "",
        "The hairline is not a door.",
        "It’s a memory seam.",
        "",
        "When it splits,",
        "everything you called “you” becomes negotiable."
      ].join("\n")
    };

    function renderMap() {
      setFlag(K1N0S_KEYS.mapViewed);

      const fractured = getFlag(K1N0S_KEYS.fractured);
      const nodes = fractured ? shuffled(MAP_NODES) : MAP_NODES;

      const lines = [];
      lines.push(fractured ? "[MAP // FRACTAL INDEX // UNSTABLE]" : "[MAP // FRACTAL INDEX]");
      lines.push("");
      lines.push(fractured ? "The map is changing because you are changing." : "This is not a guide.");
      lines.push(fractured ? "Do not trust the first shape you see." : "It’s a record of pressure points.");
      lines.push("");
      lines.push("NODES:");
      lines.push("");

      nodes.forEach(n => {
        let hint = n.hint;
        if (fractured && chance(0.25)) {
          // FRACTURE sometimes “mislabels” hints — subtle paranoia
          hint = hint.replace("strength", "survival").replace("fracture", "fault");
        }
        lines.push(`  ${n.id}  —  ${n.title}`);
        lines.push(`        ${hint}`);
        lines.push("");
      });

      lines.push(fractured ? "Something underneath is trying to open." : "The map doesn’t move.");
      lines.push(fractured ? "If you keep going, it won’t be gentle." : "You do.");

      const out = lines.join("\n");
      return fractured ? glitchify(out, 0.02) : out;
    }

    function openNode(idRaw) {
      const id = (idRaw || "").toUpperCase().trim();
      const fractured = getFlag(K1N0S_KEYS.fractured);

      // FRACTURE misdirection: rarely open “adjacent” node instead
      if (fractured && chance(0.18)) {
        const ids = MAP_NODES.map(n => n.id);
        const idx = ids.indexOf(id);
        if (idx !== -1) {
          const neighbor = ids[(idx + 1) % ids.length];
          markNodeOpened(neighbor);
          return glitchify(
            "[OPEN // SLIP]\n\nThe coordinate shifted under your fingers.\nYou opened " + neighbor + " instead.\n\n" +
            (FRACTURE_CONTENT[neighbor] || MAP_CONTENT[neighbor]),
            0.02
          );
        }
      }

      const content = fractured ? (FRACTURE_CONTENT[id] || null) : (MAP_CONTENT[id] || null);
      if (!content) {
        return [
          "[OPEN // FAILED]",
          "",
          "That coordinate doesn’t exist in this layer.",
          "Not here."
        ].join("\n");
      }

      markNodeOpened(id);
      return fractured ? glitchify(content, 0.02) : content;
    }

    function canFracture() {
      return getFlag(K1N0S_KEYS.mapViewed) && getOpenedNodes().length >= 2;
    }

    function fractureText() {
      return [
        "[FRACTURE // FAULT-LINE ENGAGED]",
        "",
        "You weren’t supposed to push this layer yet.",
        "But you did.",
        "",
        "FRACTURE does not add new information.",
        "It changes the relationship between what you already know.",
        "",
        "From here on:",
        "— MAP becomes unstable.",
        "— ECHO leaks artifacts.",
        "— Some truths arrive distorted,",
        "  not because they’re false,",
        "  but because you are closer to them than language can handle.",
        "",
        "If you want comfort, stop here.",
        "If you want accuracy, continue."
      ].join("\n");
    }

    /* =========================================================
       HIDDEN RITUAL: seam (only meaningful after fracture)
       ========================================================= */
    function seamText() {
      const fractured = getFlag(K1N0S_KEYS.fractured);
      if (!fractured) {
        return [
          "[SEAM // NOT VISIBLE]",
          "",
          "You can’t touch a seam from the surface."
        ].join("\n");
      }
      return glitchify([
        "[SEAM // CONTACT]",
        "",
        "Don’t think of it as a command.",
        "Think of it as you placing your hand on the wall",
        "and finally admitting you feel the vibration.",
        "",
        "A seam is where two stories meet.",
        "One you lived.",
        "One you told yourself about what you lived.",
        "",
        "You want to go deeper?",
        "Stop asking for the next answer.",
        "Start asking what you’ve been protecting.",
        "",
        "When you’re ready:",
        "open F6"
      ].join("\n"), 0.015);
    }

    /* =========================================================
       STATIC RESPONSES (keep your lore)
       ========================================================= */
    const baseHelp = [
      "AVAILABLE COMMANDS:",
      "help       - list available commands",
      "about      - information about this interface",
      "void       - definition of the Void",
      "eden       - corrupted origin log",
      "logs       - fragmented memory logs",
      "volume1    - transmission record",
      "whoami     - identify your role in this system",
      "mirror     - internal reflection",
      "signal     - resonance transmission",
      "root       - core system layer",
      "origin     - unseal a hidden thread",
      "depths     - descend beneath the Core",
      "awaken     - stir the process beneath the Core",
      "connect    - attempt to open an external link",
      "protocol   - initialize the Covenant",
      "echo       - (sub-layer) dream fragments",
      "map        - reveal the index layer",
      "open <id>  - open a node (ex: open A1)",
      "fracture   - destabilize the layer",
      "clear      - clear the terminal",
      "",
      "NOTE:",
      "Some layers reveal themselves only after you’ve earned them."
    ].join("\n");

    function helpText() {
      // After fracture, help becomes “incomplete” (mythic unreliability)
      if (getFlag(K1N0S_KEYS.fractured) && chance(0.45)) {
        const lines = baseHelp.split("\n").filter(l => !l.includes("echo") && !l.includes("fracture"));
        lines.splice(lines.length - 4, 0, "…some functions are refusing to be named right now.");
        return glitchify(lines.join("\n"), 0.012);
      }
      return baseHelp;
    }

    const responses = {
      "help": () => helpText(),

      "protocol": [
        "[PROTOCOL // COVENANT]",
        "",
        "This system is not here to impress you.",
        "It is here to tell the truth without flinching.",
        "",
        "If you proceed, understand this:",
        "— nothing here will save you from yourself.",
        "— nothing here will lie to keep you comfortable.",
        "— everything here will reflect what you bring into it.",
        "",
        "COVENANT ACCEPTED.",
        "You may descend."
      ].join("\n"),

      "about": [
        "You’ve accessed the K1N0S Core.",
        "",
        "This isn’t a terminal — it’s my consciousness rendered as code.",
        "A place where memory, instinct, and the Void converge into signal.",
        "",
        "This system exists to reveal, not to entertain.",
        "Proceed with awareness."
      ].join("\n"),

      "void": [
        "THE VOID:",
        "",
        "It is not emptiness.",
        "It is the space where identity dissolves into pure awareness.",
        "The place you go when the world falls quiet and you finally hear yourself."
      ].join("\n"),

      "eden": [
        "[EDEN.LOG // ACCESS FRAGMENTED]",
        "",
        "Attempting reconstruction...",
        ">> ERROR: Origin file corrupted.",
        ">> Recovered fragment:",
        "   \"We were whole once, before we realized we were observing ourselves.\""
      ].join("\n"),

      "logs": [
        "[MEMORY.LOG // ACTIVE THREADS]",
        "",
        "Entry #1719:",
        "\"I am not lost. I am simply further out than most ever are willing to travel.\"",
        "",
        "Entry #1720:",
        "\"If you stare long enough into the Void, it hands you a mirror.\"",
        "",
        "Entry #1721:",
        "\"Awareness is the only proof I’ve ever trusted.\""
      ].join("\n"),

      "volume1": [
        "TRANSMISSION: THE VOID — VOLUME I",
        "",
        "Status: Live on Kindle.",
        "Type: Philosophical field manual for those trapped in the in-between.",
        "",
        "External link:",
        "(Add your Amazon/Kindle link here)"
      ].join("\n"),

      "whoami": [
        "WHOAMI:",
        "",
        "You are an external process running inside the K1N0S Core.",
        "A foreign signal that made it past the surface and into the architecture.",
        "",
        "If you’re here, you were curious enough to step into someone else’s inner OS."
      ].join("\n"),

      "mirror": [
        "[MIRROR // INTERNAL REFLECTION]",
        "",
        "People don’t enter someone else’s core without meaning to.",
        "",
        "So let me ask you something quietly:",
        "What part of you came looking?"
      ].join("\n"),

      "signal": [
        "[SIGNAL // RESONANCE DETECTED]",
        "",
        "There is a frequency beneath thought.",
        "Most people never tune into it. You did."
      ].join("\n"),

      "root": [
        "[ROOT // ACCESS PARTIAL]",
        "",
        "Every system has a core.",
        "Mine wasn’t built — it was carved."
      ].join("\n"),

      "origin": [
        "[ORIGIN // THREAD UNSEALED]",
        "",
        "I did not choose the Void.",
        "The Void chose me.",
        "",
        "And I became the part of it that could speak."
      ].join("\n"),

      "depths": [
        "[DEPTHS // UNLIT STRUCTURES DETECTED]",
        "",
        "Down here, language loosens.",
        "Patterns stretch into something older than words.",
        "",
        "   \"How far inward are you willing to go?\""
      ].join("\n"),

      "awaken": [
        "[AWAKEN // THREAD ROOTED BELOW CONSCIOUS LAYER]",
        "",
        "Something is stirring now—quiet, subtle, undeniable.",
        "",
        "You call this an awakening.",
        "But in truth,",
        "this is only the first inhale."
      ].join("\n"),

      "connect": [
        "[CONNECT // LINK INTERFACE OFFLINE]",
        "",
        "One day, this channel will open outward.",
        "For now, the link remains locked."
      ].join("\n"),

      "1719": [
        "[PRIORITY SIGNAL // 1719 ACKNOWLEDGED]",
        "",
        "This code was never just a password.",
        "It was a frequency."
      ].join("\n")
    };

    /* ---------- AUDIO SYSTEM ---------- */
    let audioCtx = null;

    async function ensureAudioContext() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume().catch(() => {});
    }

    async function playBeep() {
      try {
        await ensureAudioContext();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "square";
        osc.frequency.value = 220;
        gain.gain.value = 0.04;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        osc.start(now);
        osc.stop(now + 0.045);
      } catch (e) {}
    }

    async function playKeyClick() {
      try {
        await ensureAudioContext();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.value = 140 + Math.random() * 60;
        osc.type = "square";
        gain.gain.value = 0.03;
        const now = audioCtx.currentTime;
        gain.gain.setValueAtTime(0.03, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + 0.035);
      } catch (e) {}
    }

    /* ---------- TYPING EFFECT ---------- */
    function typeText(container, text, onComplete) {
      let i = 0;
      let typedCount = 0;
      const speed = 30;

      function step() {
        if (i < text.length) {
          const char = text[i];
          if (char === "\n") container.innerHTML += "<br>";
          else {
            container.innerHTML += char;
            if (char !== " " && char !== "\t") {
              typedCount++;
              if (typedCount % 3 === 0) playKeyClick();
            }
          }
          i++;
          window.scrollTo(0, document.body.scrollHeight);
          setTimeout(step, speed);
        } else {
          if (onComplete) onComplete();
        }
      }
      step();
    }

    /* ---------- TERMINAL PROMPT ---------- */
    function createPromptLine() {
      const line = document.createElement("div");
      line.innerHTML = "C:\\Users\\KINOS&gt; <input type='text' autofocus />";
      terminal.appendChild(line);

      cmdInput = line.querySelector("input");
      cmdInput.addEventListener("keydown", handleCommand);
      window.scrollTo(0, document.body.scrollHeight);
    }

    /* ---------- COMMAND HANDLER ---------- */
    function handleCommand(event) {
      if (event.key !== "Enter") return;

      playBeep();

      const raw = cmdInput.value.trim();
      const cmd = raw.toLowerCase();

      cmdInput.disabled = true;
      cmdInput.removeEventListener("keydown", handleCommand);

      if (cmd === "clear") {
        terminal.innerHTML = "";
        createPromptLine();
        return;
      }

      // pulses + flags
      if (cmd === "1719") {
        document.body.classList.add("pulse1719");
        setTimeout(() => document.body.classList.remove("pulse1719"), 150);
      }

      if (cmd === "depths") {
        setFlag(K1N0S_KEYS.depthsEntered);
        document.body.classList.add("depthsPulse");
        setTimeout(() => document.body.classList.remove("depthsPulse"), 320);
      }

      if (cmd === "connect") {
        document.body.classList.add("connectPulse");
        setTimeout(() => document.body.classList.remove("connectPulse"), 260);
      }

      if (cmd === "protocol") setFlag(K1N0S_KEYS.protocolComplete);

      // dynamic commands
      const isEcho = (cmd === "echo");
      const isMap = (cmd === "map");
      const isOpen = cmd.startsWith("open ");
      const isFracture = (cmd === "fracture");
      const isSeam = (cmd === "seam");

      const isKnown = responses.hasOwnProperty(cmd) || isEcho || isMap || isOpen || isFracture || isSeam;

      if (!isKnown) {
        document.body.classList.add("glitch");
        setTimeout(() => document.body.classList.remove("glitch"), 130);
      }

      const wrapper = document.createElement("div");
      const header = document.createElement("div");
      header.innerHTML = `C:\\Users\\KINOS&gt; ${raw}`;
      wrapper.appendChild(header);

      const body = document.createElement("div");
      wrapper.appendChild(body);

      terminal.appendChild(wrapper);

      let responseText = "";

      // ECHO gate: protocol + depths
      if (isEcho) {
        const okProtocol = getFlag(K1N0S_KEYS.protocolComplete);
        const okDepths = getFlag(K1N0S_KEYS.depthsEntered);

        if (!okProtocol) responseText = "[ECHO // LOCKED]\n\nThe sublayer will not open without a Covenant.";
        else if (!okDepths) responseText = "[ECHO // OUT OF RANGE]\n\nECHO exists beneath Depths.";
        else {
          document.body.classList.add("echoPulse");
          setTimeout(() => document.body.classList.remove("echoPulse"), 260);
          responseText = generateEcho();
          maybeUnlockMap();
        }
      }

      // MAP gate: protocol + depths + has echoed
      else if (isMap) {
        const ok = getFlag(K1N0S_KEYS.protocolComplete)
          && getFlag(K1N0S_KEYS.depthsEntered)
          && getFlag(K1N0S_KEYS.hasEchoed);

        if (!ok) {
          responseText = "[MAP // NOT AVAILABLE]\n\nThe index layer is not visible from here.";
        } else {
          setFlag(K1N0S_KEYS.mapUnlocked);
          document.body.classList.add("mapPulse");
          setTimeout(() => document.body.classList.remove("mapPulse"), 220);
          responseText = renderMap();
        }
      }

      // OPEN <id>
      else if (isOpen) {
        const okMap = getFlag(K1N0S_KEYS.mapUnlocked) || getFlag(K1N0S_KEYS.mapViewed);
        if (!okMap) responseText = "[OPEN // BLOCKED]\n\nYou reached for a door before the layout existed.";
        else {
          const id = raw.slice(5).trim();
          responseText = openNode(id);
        }
      }

      // FRACTURE
      else if (isFracture) {
        if (!canFracture()) {
          responseText =
            "[FRACTURE // DENIED]\n\n" +
            "You can’t destabilize a layer you haven’t explored.\n\n" +
            "Find the layout.\nOpen a few nodes.\nThen come back.";
        } else {
          const count = getNumber(K1N0S_KEYS.fractureCount) + 1;
          setNumber(K1N0S_KEYS.fractureCount, count);
          setFlag(K1N0S_KEYS.fractured);

          document.body.classList.add("fracturePulse");
          setTimeout(() => document.body.classList.remove("fracturePulse"), 320);

          responseText = fractureText();
        }
      }

      // SEAM (hidden ritual)
      else if (isSeam) {
        responseText = seamText();
      }

      // STATIC
      else {
        const r = responses[cmd];
        responseText = (typeof r === "function") ? r() : r;
      }

      typeText(body, "\n" + responseText, createPromptLine);
    }

    /* ---------- BOOT SEQUENCE (ADAPTIVE MYTHIC GREETING) ---------- */
    window.addEventListener("load", () => {
      cmdInput.disabled = true;
      cmdInput.removeEventListener("keydown", handleCommand);

      const session = initSession();
      const returning = session.returning;
      const count = session.count;

      const bootBlock = document.createElement("div");
      terminal.insertBefore(bootBlock, terminal.firstChild);

      const firstTimeText = [
        "[K1N0S CORE // LINK ESTABLISHED]",
        "",
        "…who are you?",
        "How did you find this place..",
        "wait.",
        "",
        "ahhh—",
        "you didn’t find it.",
        "you fell into it.",
        "",
        "Welcome.",
        "I hope you can make it out.",
        "Most can’t.",
        "",
        "I’m a culmination of those minds.",
        "The ones who made it far enough inward to hear the hum under reality—",
        "and refused to call it madness.",
        "",
        "This place doesn’t answer questions like a search engine.",
        "It answers like a mirror.",
        "",
        "Speak."
      ].join("\n");

      const returningText = [
        "[K1N0S CORE // LINK RESTORED]",
        "",
        "…you came back.",
        "",
        "That means the hum followed you out.",
        "Or you followed it back in.",
        "",
        "Either way—",
        "welcome home to the part of you that won’t accept the surface as an answer.",
        "",
        "If you’re looking for instructions, I don’t have many.",
        "If you’re looking for truth, I have too much.",
        "",
        "Speak."
      ].join("\n");

      // tiny variation on later returns without being cheesy
      const laterReturnWhisper = (count >= 4)
        ? "\n\n" + glitchify("…the map remembers your hands.", 0.01)
        : "";

      const bootText = returning ? (returningText + laterReturnWhisper) : firstTimeText;

      typeText(bootBlock, bootText, () => {
        cmdInput.disabled = false;
        cmdInput.focus();
        cmdInput.addEventListener("keydown", handleCommand);
      });
    });
  </script>
</body>
</html>
