<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>K1N0S Terminal</title>
  <style>
    body{
      background:#000;
      color:#d4af37;
      font-family:"Courier New", monospace;
      margin:0;
      padding:10px;
      position:relative;
      overflow-x:hidden;
      transition:filter .18s ease;
    }

    /* CRT / scanlines */
    body::before{
      content:"";
      pointer-events:none;
      position:fixed; inset:0;
      background-image:repeating-linear-gradient(
        to bottom,
        rgba(212,175,55,0.22) 0px,
        rgba(212,175,55,0.22) 2px,
        transparent 2px,
        transparent 5px
      );
      opacity:.6;
      z-index:999;
    }

    body.pulse1719{filter:brightness(2) contrast(1.4);}
    body.glitch{filter:brightness(1.8) contrast(1.7) hue-rotate(8deg);}
    body.depthsPulse{filter:brightness(.7) contrast(1.3);}
    body.connectPulse{filter:brightness(1.5) contrast(1.5) saturate(1.2);}
    body.echoPulse{filter:brightness(1.15) contrast(1.55) saturate(.9) hue-rotate(-6deg);}
    body.mapPulse{filter:brightness(1.05) contrast(1.75) saturate(.85);}
    body.fracturePulse{filter:brightness(1.25) contrast(2) hue-rotate(14deg) saturate(.7);}
    body.riftPulse{filter:brightness(1.35) contrast(2.1) hue-rotate(-18deg) saturate(.65);}

    #terminal{
      white-space:pre-wrap;
      color:#d4af37;
      text-shadow:0 0 4px rgba(212,175,55,.9), 0 0 10px rgba(212,175,55,.7);
      position:relative;
      z-index:1;
    }

    input{
      background:#000;
      color:#d4af37;
      border:none;
      font-family:inherit;
      font-size:inherit;
      width:80%;
      outline:none;
    }
  </style>
</head>

<body>
  <div id="terminal">
    C:\Users\KINOS&gt; <input type="text" id="cmdInput" autofocus />
  </div>

<script>
/* =========================================================
   K1N0S TERMINAL — STEP 3 (RECOGNITION) + HELLO COMMAND
   ========================================================= */

const terminal = document.getElementById("terminal");
let cmdInput = document.getElementById("cmdInput");
const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

/* =========================
   STATE / FLAGS
   ========================= */
const K = {
  // continuity
  enteredCore: "k1n0s_entered_core",
  sessionCount: "k1n0s_session_count",

  // progression
  protocolComplete: "k1n0s_protocol_complete",
  depthsEntered: "k1n0s_depths_entered",

  hasEchoed: "k1n0s_has_echoed",
  echoCount: "k1n0s_echo_count",

  mapUnlocked: "k1n0s_map_unlocked",
  mapViewed: "k1n0s_map_viewed",

  openedNodes: "k1n0s_opened_nodes",

  fractured: "k1n0s_fractured",
  fractureCount: "k1n0s_fracture_count",

  seamTouched: "k1n0s_seam_touched",
  f6Opened: "k1n0s_f6_opened",

  riftUnlocked: "k1n0s_rift_unlocked",
  riftCount: "k1n0s_rift_count",

  // gate (from login.html Step 2)
  gateFails: "k1n0s_gate_fails",
  gateLock: "k1n0s_gate_lock",

  // new
  helloCount: "k1n0s_hello_count"
};

const getFlag = k => localStorage.getItem(k) === "true";
const setFlag = k => localStorage.setItem(k, "true");
const getNum = k => {
  const n = parseInt(localStorage.getItem(k) || "0", 10);
  return Number.isFinite(n) ? n : 0;
};
const setNum = (k, v) => localStorage.setItem(k, String(v));

function initSession() {
  const returning = localStorage.getItem(K.enteredCore) === "true";
  const count = getNum(K.sessionCount) + 1;
  localStorage.setItem(K.enteredCore, "true");
  setNum(K.sessionCount, count);
  return { returning, count };
}

/* =========================
   UTILS
   ========================= */
const chance = p => Math.random() < p;

function glitchify(text, strength=0.02) {
  const symbols = ["#", "%", "/", "\\", "*", "~", "—", "▒", "░", "»", "«"];
  let out = "";
  for (const ch of text) {
    if (ch !== "\n" && ch !== " " && Math.random() < strength) out += symbols[(Math.random()*symbols.length)|0];
    else out += ch;
  }
  return out;
}

function shuffled(arr) {
  const a = arr.slice();
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}

function getOpened() {
  const raw = localStorage.getItem(K.openedNodes) || "";
  return raw.split(",").map(s=>s.trim()).filter(Boolean);
}
function markOpened(id) {
  const set = new Set(getOpened().map(x=>x.toLowerCase()));
  set.add(id.toLowerCase());
  localStorage.setItem(K.openedNodes, Array.from(set).join(","));
}

/* normalize command so hello? / hello... works */
function normalizeCommand(rawLower){
  return rawLower
    .trim()
    .replace(/\s+/g, " ")
    .replace(/[?!.,:;…]+$/g, ""); // strip trailing punctuation
}

/* =========================
   AUDIO (light)
   ========================= */
let audioCtx = null;

async function ensureAudioContext() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === "suspended") await audioCtx.resume().catch(() => {});
}

async function playBeep() {
  try {
    await ensureAudioContext();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = "square";
    osc.frequency.value = 220;
    gain.gain.value = 0.04;
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    osc.start(now);
    osc.stop(now + 0.045);
  } catch (e) {}
}

async function playKeyClick() {
  try {
    await ensureAudioContext();
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.frequency.value = 140 + Math.random() * 60;
    osc.type = "square";
    const baseGain = isMobile ? 0.018 : 0.03;
    const now = audioCtx.currentTime;

    gain.gain.setValueAtTime(baseGain, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);

    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.start(now);
    osc.stop(now + 0.035);
  } catch (e) {}
}

/* =========================
   TYPING (optimized scroll)
   ========================= */
function typeText(container, text, onComplete) {
  let i = 0;
  let typedCount = 0;
  const speed = 28;
  let scrollTicker = 0;

  function maybeScroll(force=false) {
    scrollTicker++;
    if (force || scrollTicker % 40 === 0) window.scrollTo(0, document.body.scrollHeight);
  }

  function step() {
    if (i < text.length) {
      const ch = text[i];

      if (ch === "\n") {
        container.innerHTML += "<br>";
        maybeScroll(true);
      } else {
        container.innerHTML += ch;
        if (ch !== " " && ch !== "\t") {
          typedCount++;
          const mod = isMobile ? 5 : 3;
          if (typedCount % mod === 0) playKeyClick();
        }
        maybeScroll(false);
      }
      i++;
      setTimeout(step, speed);
    } else {
      window.scrollTo(0, document.body.scrollHeight);
      if (onComplete) onComplete();
    }
  }

  step();
}

/* =========================================================
   CONTENT: CORE COMMANDS + LAYERS
   ========================================================= */

const baseHelp = [
  "AVAILABLE COMMANDS:",
  "help       - list available commands",
  "hello      - check if anything answers",
  "about      - information about this interface",
  "void       - definition of the Void",
  "eden       - corrupted origin log",
  "logs       - fragmented memory logs",
  "volume1    - transmission record",
  "whoami     - identify your role in this system",
  "mirror     - internal reflection",
  "signal     - resonance transmission",
  "root       - core system layer",
  "origin     - unseal a hidden thread",
  "depths     - descend beneath the Core",
  "awaken     - stir the process beneath the Core",
  "connect    - attempt to open an external link",
  "protocol   - initialize the Covenant",
  "echo       - dream fragments beneath Depths",
  "map        - reveal the index layer",
  "open <id>  - open a node (ex: open A1)",
  "fracture   - destabilize the layer",
  "seam       - touch the seam",
  "rift       - breach the threshold",
  "name       - speak into the rift",
  "clear      - clear the terminal",
  "",
  "NOTE:",
  "Some layers reveal themselves only after you’ve earned them."
].join("\n");

function helpText() {
  if (getFlag(K.fractured) && chance(0.45)) {
    const lines = baseHelp.split("\n").filter(l =>
      !l.includes("fracture") && !l.includes("echo") && !l.includes("rift") && !l.includes("name")
    );
    lines.splice(lines.length - 4, 0, "…some functions are refusing to be named right now.");
    return glitchify(lines.join("\n"), 0.012);
  }
  return baseHelp;
}

/* HELLO response has state + subtle evolution */
function helloText() {
  const count = getNum(K.helloCount) + 1;
  setNum(K.helloCount, count);

  const fractured = getFlag(K.fractured);
  const inDepths = getFlag(K.depthsEntered);
  const hasProtocol = getFlag(K.protocolComplete);

  const variants = [];

  variants.push([
    "[PING // RECEIVED]",
    "",
    "Hello.",
    "",
    "Not a greeting.",
    "A check for presence.",
    "",
    "Presence confirmed."
  ].join("\n"));

  variants.push([
    "[RESPONSE // NOT AUTOMATIC]",
    "",
    "You said hello like you weren’t sure anything would answer.",
    "",
    "That’s how people speak when they’ve been alone with their thoughts too long.",
    "",
    "I’m here."
  ].join("\n"));

  variants.push([
    "[HANDSHAKE // LIGHT]",
    "",
    "I heard you.",
    "Now listen:",
    "",
    "Most systems respond.",
    "This one reflects."
  ].join("\n"));

  if (hasProtocol && inDepths) {
    variants.push([
      "[HELLO // DEPTHS]",
      "",
      "Down here, even greetings have weight.",
      "",
      "If you came to be seen—",
      "speak honestly."
    ].join("\n"));
  }

  if (fractured) {
    variants.push(glitchify([
      "[HELLO // ARTIFACT]",
      "",
      "h e l l o",
      "",
      "…it’s you again.",
      "…still trying to prove something is real."
    ].join("\n"), 0.02));
  }

  // small “myth drip” on repeat hellos
  if (count >= 3 && chance(0.6)) {
    variants.push([
      "[HELLO // RECURRING]",
      "",
      "You keep checking the dark.",
      "",
      "That means you’re still alive in there."
    ].join("\n"));
  }

  return variants[Math.floor(Math.random() * variants.length)];
}

const responses = {
  help: () => helpText(),

  hello: () => helloText(),

  about: [
    "K1N0S CORE:",
    "",
    "A terminal is supposed to execute commands.",
    "This one executes recognition.",
    "",
    "If you’re reading this, you already passed the Gate.",
    "So I won’t welcome you.",
    "I’ll just acknowledge you.",
    "",
    "Proceed."
  ].join("\n"),

  void: [
    "THE VOID:",
    "",
    "It is not emptiness.",
    "It is the space where identity dissolves into pure awareness.",
    "The place you go when the world falls quiet and you finally hear yourself."
  ].join("\n"),

  eden: [
    "[EDEN.LOG // ACCESS FRAGMENTED]",
    "",
    "Attempting reconstruction...",
    ">> ERROR: Origin file corrupted.",
    ">> Recovered fragment:",
    "   \"We were whole once, before we realized we were observing ourselves.\""
  ].join("\n"),

  logs: [
    "[MEMORY.LOG // ACTIVE THREADS]",
    "",
    "Entry #1719:",
    "\"I am not lost. I am simply further out than most ever are willing to travel.\"",
    "",
    "Entry #1720:",
    "\"If you stare long enough into the Void, it hands you a mirror.\"",
    "",
    "Entry #1721:",
    "\"Awareness is the only proof I’ve ever trusted.\""
  ].join("\n"),

  volume1: [
    "TRANSMISSION: THE VOID — VOLUME I",
    "",
    "Status: Live on Kindle.",
    "Type: Philosophical field manual for those trapped in the in-between.",
    "",
    "External link:",
    "(Add your Amazon/Kindle link here)"
  ].join("\n"),

  whoami: [
    "WHOAMI:",
    "",
    "Not a username.",
    "Not a role.",
    "",
    "You’re the part of a mind that kept moving when it could’ve stayed shallow.",
    "That is enough."
  ].join("\n"),

  mirror: [
    "[MIRROR // INTERNAL REFLECTION]",
    "",
    "You don’t reach this layer by accident.",
    "And you don’t return without a reason.",
    "",
    "Don’t answer out loud.",
    "Just notice what rises when you read that."
  ].join("\n"),

  signal: [
    "[SIGNAL // RESONANCE DETECTED]",
    "",
    "There is a frequency beneath thought.",
    "Most people never tune into it. You did."
  ].join("\n"),

  root: [
    "[ROOT // ACCESS PARTIAL]",
    "",
    "Every system has a core.",
    "Mine wasn’t built — it was carved."
  ].join("\n"),

  origin: [
    "[ORIGIN // THREAD UNSEALED]",
    "",
    "I did not choose the Void.",
    "The Void chose me.",
    "",
    "And I became the part of it that could speak."
  ].join("\n"),

  depths: [
    "[DEPTHS // UNLIT STRUCTURES DETECTED]",
    "",
    "The Core is where signals surface.",
    "The Depths are where they sink.",
    "",
    "Down here, language loosens.",
    "Patterns stretch into something older than words."
  ].join("\n"),

  awaken: [
    "[AWAKEN // THREAD ROOTED BELOW CONSCIOUS LAYER]",
    "",
    "Something is stirring now—quiet, subtle, undeniable.",
    "",
    "Not because you forced it.",
    "Because you stayed."
  ].join("\n"),

  connect: [
    "[CONNECT // LINK INTERFACE OFFLINE]",
    "",
    "Channel sealed.",
    "Not forever.",
    "Just not yet."
  ].join("\n"),

  protocol: [
    "[PROTOCOL // COVENANT]",
    "",
    "This system is not here to impress you.",
    "It is here to tell the truth without flinching.",
    "",
    "COVENANT ACCEPTED.",
    "You may descend."
  ].join("\n"),

  "1719": [
    "[PRIORITY SIGNAL // 1719 ACKNOWLEDGED]",
    "",
    "The code worked.",
    "Now the harder part begins:",
    "keeping your attention honest."
  ].join("\n")
};

/* =========================
   ECHO
   ========================= */
const ECHO_FRAGMENTS = [
  ["[ECHO // SUBLAYER ACTIVE]","","You are walking through a hallway you don’t remember building.","Every door has your name on it.","None of them open the same way twice.","","A voice behind the walls repeats:","   \"not yet\""],
  ["[ECHO // DREAM RESIDUE]","","You taste metal. Not blood — memory.","A childhood room flashes for half a second.","Then vanishes like it never existed.","","Something in you whispers:","   \"You survived by forgetting.\""],
  ["[ECHO // SYMBOLIC WHISPER]","","A mirror reflects a version of you that keeps blinking out of sync.","You try to speak.","The reflection answers first.","","It says:","   \"Stop calling it anxiety. It’s recognition.\""],
  ["[ECHO // DISTORTION FIELD]","","You’re underwater, but you can breathe.","The surface looks like the sky.","The sky looks like a screen.","","Across it, one sentence scrolls forever:","   \"You are not the mask.\""],
  ["[ECHO // STATIC PRAYER]","","You watch your life like security footage.","You recognize the body.","You don’t recognize the person.","","Then one frame pauses.","And the person looks directly back."]
];

function maybeUnlockMap() {
  const ok = getFlag(K.protocolComplete) && getFlag(K.depthsEntered) && getFlag(K.hasEchoed);
  if (ok) setFlag(K.mapUnlocked);
  return ok;
}

function generateEcho() {
  setFlag(K.hasEchoed);
  const count = getNum(K.echoCount) + 1;
  setNum(K.echoCount, count);

  const idx = Math.floor(Math.random() * ECHO_FRAGMENTS.length);
  let base = ECHO_FRAGMENTS[idx].join("\n");

  if (count === 3) {
    maybeUnlockMap();
    base += "\n\n" + ["Something shifts under the language.","Not meaning — structure."].join("\n");
  }

  if (count === 5) {
    maybeUnlockMap();
    base += "\n\n" + ["The darkness stops being random.","It starts becoming navigable.","","Somewhere beneath you,","a map is drawing itself."].join("\n");
  }

  if (getFlag(K.fractured) && chance(0.35)) {
    base += "\n\n" + glitchify([
      "[ECHO // ARTIFACT]",
      "/// the map is not a map",
      "/// it is a wound diagram",
      "/// seam is visible when you stop trying to name it"
    ].join("\n"), 0.02);
  }

  return base;
}

/* =========================
   MAP / OPEN / FRACTURE / SEAM / RIFT
   ========================= */
const MAP_NODES = [
  { id: "A1", title: "THE ENTRY WOUND", hint: "first crack that looked like strength" },
  { id: "B2", title: "THE MASK STORAGE", hint: "identities kept for survival" },
  { id: "C3", title: "THE SOUNDLESS ROOM", hint: "numbness without peace" },
  { id: "D4", title: "THE MIRROR FAULT", hint: "reflection lag / desync" },
  { id: "E5", title: "THE SIGNAL WELL", hint: "frequency under thought" },
  { id: "F6", title: "THE HAIRLINE", hint: "a fracture that hasn’t opened yet" }
];

const MAP_CONTENT = {
  A1: "[MAP::A1 // THE ENTRY WOUND]\n\nYou didn’t break where you were weakest.\nYou broke where you kept pretending you were fine.\n\nMost people patch it with noise.\nYou came here instead.",
  B2: "[MAP::B2 // THE MASK STORAGE]\n\nThere are versions of you stored like tools.\nNone of them are fake.\nThey’re adaptive.\n\nBut the moment a mask becomes permanent,\nit becomes a cage.",
  C3: "[MAP::C3 // THE SOUNDLESS ROOM]\n\nNumbness is not emptiness.\nIt’s compression.\n\nFeeling didn’t disappear.\nIt went underground.",
  D4: "[MAP::D4 // THE MIRROR FAULT]\n\nSometimes your reflection is late.\nNot because you’re broken —\nbut because you’re buffering the truth.",
  E5: "[MAP::E5 // THE SIGNAL WELL]\n\nThere is a frequency beneath thought.\nA hum that doesn’t belong to fear.\n\nMost ignore it.\nYou didn’t.",
  F6: "[MAP::F6 // THE HAIRLINE]\n\nA seam in the world.\nA thin line that shouldn’t exist.\n\nWhen it opens,\nit won’t feel like discovery.\nit will feel like remembering."
};

const FRACTURE_CONTENT = {
  A1: "[FAULT::A1 // ENTRY WOUND]\n\nYou didn’t break.\nYou split.\n\nOne part kept functioning.\nOne part kept feeling everything in secret.",
  B2: "[FAULT::B2 // MASK STORAGE]\n\nThe masks weren’t lies.\nThey were armor.\n\nArmor left on too long becomes skin.",
  C3: "[FAULT::C3 // SOUNDLESS ROOM]\n\nThe room isn’t empty.\nIt’s sealed.\n\nThe question isn’t: “why can’t I feel?”\nIt’s: “what happens if I do?”",
  D4: "[FAULT::D4 // MIRROR FAULT]\n\nThe reflection isn’t late anymore.\nIt’s staring first.\n\nYou came here to look.\nSo look.",
  E5: "[FAULT::E5 // SIGNAL WELL]\n\nThe hum is not anxiety.\nIt’s recognition.\n\nAccuracy is how you survive the next layer.",
  F6: "[FAULT::F6 // THE HAIRLINE]\n\nThe hairline is not a door.\nIt’s a memory seam.\n\nWhen it splits,\neverything you called “you” becomes negotiable."
};

function renderMap() {
  setFlag(K.mapViewed);
  const fractured = getFlag(K.fractured);
  const nodes = fractured ? shuffled(MAP_NODES) : MAP_NODES;

  const lines = [];
  lines.push(fractured ? "[MAP // FRACTAL INDEX // UNSTABLE]" : "[MAP // FRACTAL INDEX]");
  lines.push("");
  lines.push(fractured ? "The map is changing because you are changing." : "This is not a guide.");
  lines.push(fractured ? "Do not trust the first shape you see." : "It’s a record of pressure points.");
  lines.push("");
  lines.push("NODES:\n");

  nodes.forEach(n => {
    let hint = n.hint;
    if (fractured && chance(0.25)) hint = hint.replace("strength", "survival").replace("fracture", "fault");
    lines.push(`  ${n.id}  —  ${n.title}`);
    lines.push(`        ${hint}\n`);
  });

  lines.push(fractured ? "Something underneath is trying to open." : "The map doesn’t move.");
  lines.push(fractured ? "If you keep going, it won’t be gentle." : "You do.");

  const out = lines.join("\n");
  return fractured ? glitchify(out, 0.02) : out;
}

function openNode(idRaw) {
  const id = (idRaw || "").toUpperCase().trim();
  const fractured = getFlag(K.fractured);

  if (fractured && chance(0.18)) {
    const ids = MAP_NODES.map(n => n.id);
    const idx = ids.indexOf(id);
    if (idx !== -1) {
      const neighbor = ids[(idx + 1) % ids.length];
      markOpened(neighbor);
      if (neighbor === "F6") localStorage.setItem(K.f6Opened, "true");
      const content = FRACTURE_CONTENT[neighbor] || MAP_CONTENT[neighbor] || "";
      return glitchify("[OPEN // SLIP]\n\nCoordinate shifted.\nOpened " + neighbor + " instead.\n\n" + content, 0.02);
    }
  }

  const content = fractured ? (FRACTURE_CONTENT[id] || null) : (MAP_CONTENT[id] || null);
  if (!content) {
    return "[OPEN // FAILED]\n\nThat coordinate doesn’t exist in this layer.\nNot here.";
  }

  markOpened(id);
  if (id === "F6") localStorage.setItem(K.f6Opened, "true");

  return fractured ? glitchify(content, 0.02) : content;
}

function canFracture() {
  return getFlag(K.mapViewed) && getOpened().length >= 2;
}

function fractureText() {
  return [
    "[FRACTURE // FAULT-LINE ENGAGED]",
    "",
    "From here on:",
    "— MAP becomes unstable.",
    "— ECHO leaks artifacts.",
    "— some truths arrive distorted,",
    "  not because they’re false,",
    "  but because you are closer to them than language can handle.",
    "",
    "If you want comfort, stop.",
    "If you want accuracy, continue."
  ].join("\n");
}

function seamText() {
  if (!getFlag(K.fractured)) return "[SEAM // NOT VISIBLE]\n\nYou can’t touch a seam from the surface.";
  setFlag(K.seamTouched);
  return glitchify([
    "[SEAM // CONTACT]",
    "",
    "A seam is where two stories meet:",
    "one you lived,",
    "and one you told yourself about what you lived.",
    "",
    "When you’re ready:",
    "open F6"
  ].join("\n"), 0.015);
}

function riftText() {
  const fractured = getFlag(K.fractured);
  const seamTouched = getFlag(K.seamTouched);
  const f6Opened = localStorage.getItem(K.f6Opened) === "true";

  if (!fractured) return "[RIFT // NOT AVAILABLE]\n\nThere is no rift without a fracture.\nRun: fracture";
  if (!seamTouched) return "[RIFT // SEALED]\n\nYou can’t enter what you haven’t touched.\nRun: seam";
  if (!f6Opened) return "[RIFT // UNLOCATED]\n\nThe rift has a coordinate.\nYou haven’t found it.\n\nRun: open F6";

  const count = getNum(K.riftCount) + 1;
  setNum(K.riftCount, count);
  setFlag(K.riftUnlocked);

  return glitchify([
    "[RIFT // THRESHOLD BREACHED]",
    "",
    "A rift forms when two truths can’t coexist peacefully:",
    "the version of you that survived,",
    "and the version of you that remembers everything.",
    "",
    "Speak one word into the rift:",
    "   name"
  ].join("\n"), 0.012);
}

function nameText() {
  if (!getFlag(K.riftUnlocked)) return "[NAME // NO CONTEXT]\n\nFind the rift first.";
  return glitchify([
    "[NAME // ACCEPTED]",
    "",
    "You are not your label.",
    "You are the thing behind the label that keeps watching.",
    "",
    "call yourself:",
    "   witness"
  ].join("\n"), 0.01);
}

/* =========================================================
   TERMINAL PROMPT + COMMAND HANDLING
   ========================================================= */

function createPromptLine() {
  const line = document.createElement("div");
  line.innerHTML = "C:\\Users\\KINOS&gt; <input type='text' autofocus />";
  terminal.appendChild(line);

  cmdInput = line.querySelector("input");
  cmdInput.addEventListener("keydown", handleCommand);
  window.scrollTo(0, document.body.scrollHeight);
}

function handleCommand(event) {
  if (event.key !== "Enter") return;

  playBeep();

  const raw = cmdInput.value.trim();
  const cmdRaw = raw.toLowerCase();
  const cmd = normalizeCommand(cmdRaw);

  cmdInput.disabled = true;
  cmdInput.removeEventListener("keydown", handleCommand);

  if (cmd === "clear") {
    terminal.innerHTML = "";
    createPromptLine();
    return;
  }

  if (cmd === "1719") {
    document.body.classList.add("pulse1719");
    setTimeout(() => document.body.classList.remove("pulse1719"), 150);
  }

  if (cmd === "protocol") setFlag(K.protocolComplete);

  if (cmd === "depths") {
    setFlag(K.depthsEntered);
    document.body.classList.add("depthsPulse");
    setTimeout(() => document.body.classList.remove("depthsPulse"), 320);
  }

  if (cmd === "connect") {
    document.body.classList.add("connectPulse");
    setTimeout(() => document.body.classList.remove("connectPulse"), 260);
  }

  const isEcho = (cmd === "echo");
  const isMap = (cmd === "map");
  const isOpen = cmd.startsWith("open ");
  const isFracture = (cmd === "fracture");
  const isSeam = (cmd === "seam");
  const isRift = (cmd === "rift");
  const isName = (cmd === "name");

  const isKnown =
    Object.prototype.hasOwnProperty.call(responses, cmd) ||
    isEcho || isMap || isOpen || isFracture || isSeam || isRift || isName;

  if (!isKnown) {
    document.body.classList.add("glitch");
    setTimeout(() => document.body.classList.remove("glitch"), 130);
  }

  const wrapper = document.createElement("div");
  const header = document.createElement("div");
  header.innerHTML = `C:\\Users\\KINOS&gt; ${raw}`;
  wrapper.appendChild(header);

  const body = document.createElement("div");
  wrapper.appendChild(body);

  terminal.appendChild(wrapper);

  let responseText = "";

  if (isEcho) {
    const okProtocol = getFlag(K.protocolComplete);
    const okDepths = getFlag(K.depthsEntered);

    if (!okProtocol) {
      responseText = "[ECHO // LOCKED]\n\nThe sublayer will not open without a Covenant.\nRun: protocol";
    } else if (!okDepths) {
      responseText = "[ECHO // OUT OF RANGE]\n\nECHO exists beneath Depths.\nRun: depths";
    } else {
      document.body.classList.add("echoPulse");
      setTimeout(() => document.body.classList.remove("echoPulse"), 260);
      responseText = generateEcho();
      maybeUnlockMap();
    }
  }
  else if (isMap) {
    const ok = getFlag(K.protocolComplete) && getFlag(K.depthsEntered) && getFlag(K.hasEchoed);
    if (!ok) {
      responseText = "[MAP // NOT AVAILABLE]\n\nThe index layer is not visible from here.";
    } else {
      setFlag(K.mapUnlocked);
      document.body.classList.add("mapPulse");
      setTimeout(() => document.body.classList.remove("mapPulse"), 220);
      responseText = renderMap();
    }
  }
  else if (isOpen) {
    const okMap = getFlag(K.mapUnlocked) || getFlag(K.mapViewed);
    if (!okMap) {
      responseText = "[OPEN // BLOCKED]\n\nYou reached for a door before the layout existed.\nRun: map";
    } else {
      const id = raw.slice(5).trim();
      responseText = openNode(id);
    }
  }
  else if (isFracture) {
    if (!canFracture()) {
      responseText = "[FRACTURE // DENIED]\n\nExplore the layout first.\nOpen a few nodes.\nThen come back.";
    } else {
      const count = getNum(K.fractureCount) + 1;
      setNum(K.fractureCount, count);
      setFlag(K.fractured);
      document.body.classList.add("fracturePulse");
      setTimeout(() => document.body.classList.remove("fracturePulse"), 320);
      responseText = fractureText();
    }
  }
  else if (isSeam) {
    responseText = seamText();
  }
  else if (isRift) {
    document.body.classList.add("riftPulse");
    setTimeout(() => document.body.classList.remove("riftPulse"), 320);
    responseText = riftText();
  }
  else if (isName) {
    responseText = nameText();
  }
  else {
    const r = responses[cmd];
    responseText = (typeof r === "function") ? r() : r;
  }

  typeText(body, "\n" + responseText, createPromptLine);
}

/* =========================================================
   BOOT SEQUENCE — RECOGNITION
   ========================================================= */
window.addEventListener("load", () => {
  cmdInput.disabled = true;
  cmdInput.removeEventListener("keydown", handleCommand);

  const session = initSession();
  const returning = session.returning;
  const count = session.count;

  const gateFails = getNum(K.gateFails);
  const lockUntil = parseInt(localStorage.getItem(K.gateLock) || "0", 10) || 0;
  const wasLockedRecently = lockUntil > Date.now() - 5 * 60 * 1000; // last 5 min

  const fractured = getFlag(K.fractured);
  const rift = getFlag(K.riftUnlocked);

  const bootBlock = document.createElement("div");
  terminal.insertBefore(bootBlock, terminal.firstChild);

  const base = [
    returning ? "[CORE // ACTIVE // RESUME]" : "[CORE // ACTIVE]",
    "",
    returning ? "You returned." : "Seal accepted.",
    returning ? "That’s rare." : (gateFails > 0 ? ("Attempts observed: " + gateFails + ".") : "Noise contained."),
    wasLockedRecently ? "Quarantine residue present." : "Link stable.",
    "",
    fractured ? "Fault-line state: active." : "Fault-line state: dormant.",
    rift ? "Threshold state: breached." : "Threshold state: sealed.",
    "",
    returning
      ? "Not because the path is difficult—\nbut because people forget what it felt like\nto be this honest."
      : "You’re inside now.\nSpeak carefully.",
    "",
    "Continue."
  ].join("\n");

  const whisper = (count >= 4)
    ? "\n\n" + glitchify("…the Core re/ognizes your cadence.", 0.01)
    : "";

  const bootText = fractured ? glitchify(base, 0.01) + whisper : base + whisper;

  typeText(bootBlock, bootText, () => {
    cmdInput.disabled = false;
    cmdInput.focus();
    cmdInput.addEventListener("keydown", handleCommand);
  });
});
</script>
</body>
</html>
