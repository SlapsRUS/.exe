<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>K1N0S Terminal</title>
  <style>
    body {
      background-color: black;
      color: #d4af37;
      font-family: 'Courier New', Courier, monospace;
      margin: 0;
      padding: 10px;
      position: relative;
      overflow-x: hidden;
      transition: filter 0.18s ease;
    }

    /* CRT / scanlines */
    body::before {
      content: "";
      pointer-events: none;
      position: fixed;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-image: repeating-linear-gradient(
        to bottom,
        rgba(212, 175, 55, 0.22) 0px,
        rgba(212, 175, 55, 0.22) 2px,
        transparent 2px,
        transparent 5px
      );
      opacity: 0.6;
      z-index: 999;
    }

    /* pulses */
    body.pulse1719 { filter: brightness(2) contrast(1.4); }
    body.glitch { filter: brightness(1.8) contrast(1.7) hue-rotate(8deg); }
    body.depthsPulse { filter: brightness(0.7) contrast(1.3); }
    body.connectPulse { filter: brightness(1.5) contrast(1.5) saturate(1.2); }
    body.echoPulse { filter: brightness(1.15) contrast(1.55) saturate(0.9) hue-rotate(-6deg); }
    body.mapPulse { filter: brightness(1.05) contrast(1.75) saturate(0.85); }
    body.fracturePulse { filter: brightness(1.25) contrast(2) hue-rotate(14deg) saturate(0.7); }
    body.riftPulse { filter: brightness(1.35) contrast(2.1) hue-rotate(-18deg) saturate(0.65); }

    #terminal {
      white-space: pre-wrap;
      color: #d4af37;
      text-shadow:
        0 0 4px rgba(212, 175, 55, 0.9),
        0 0 10px rgba(212, 175, 55, 0.7);
      position: relative;
      z-index: 1;
    }

    input {
      background: black;
      color: #d4af37;
      border: none;
      font-family: inherit;
      font-size: inherit;
      width: 80%;
      outline: none;
    }
  </style>
</head>

<body>
  <div id="terminal">
    C:\Users\KINOS&gt; <input type="text" id="cmdInput" autofocus />
  </div>

  <script>
    /* =========================================================
       CORE
       ========================================================= */
    const terminal = document.getElementById('terminal');
    let cmdInput = document.getElementById('cmdInput');

    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);

    const K1N0S_KEYS = {
      // continuity
      enteredCore: "k1n0s_entered_core",
      sessionCount: "k1n0s_session_count",

      // progression
      protocolComplete: "k1n0s_protocol_complete",
      depthsEntered: "k1n0s_depths_entered",

      hasEchoed: "k1n0s_has_echoed",
      echoCount: "k1n0s_echo_count",

      mapUnlocked: "k1n0s_map_unlocked",
      mapViewed: "k1n0s_map_viewed",

      openedNodes: "k1n0s_opened_nodes",

      fractured: "k1n0s_fractured",
      fractureCount: "k1n0s_fracture_count",

      seamTouched: "k1n0s_seam_touched",
      f6Opened: "k1n0s_f6_opened",

      riftUnlocked: "k1n0s_rift_unlocked",
      riftCount: "k1n0s_rift_count",
    };

    function getFlag(key) { return localStorage.getItem(key) === "true"; }
    function setFlag(key) { localStorage.setItem(key, "true"); }

    function getNumber(key) {
      const n = parseInt(localStorage.getItem(key) || "0", 10);
      return Number.isFinite(n) ? n : 0;
    }
    function setNumber(key, value) { localStorage.setItem(key, String(value)); }

    function initSession() {
      const returning = localStorage.getItem(K1N0S_KEYS.enteredCore) === "true";
      const count = getNumber(K1N0S_KEYS.sessionCount) + 1;
      localStorage.setItem(K1N0S_KEYS.enteredCore, "true");
      setNumber(K1N0S_KEYS.sessionCount, count);
      return { returning, count };
    }

    function getOpenedNodes() {
      const raw = localStorage.getItem(K1N0S_KEYS.openedNodes) || "";
      return raw.split(",").map(s => s.trim()).filter(Boolean);
    }

    function markNodeOpened(id) {
      const opened = new Set(getOpenedNodes().map(x => x.toLowerCase()));
      opened.add(id.toLowerCase());
      localStorage.setItem(K1N0S_KEYS.openedNodes, Array.from(opened).join(","));
    }

    function chance(p) { return Math.random() < p; }

    function glitchify(text, strength=0.02) {
      const symbols = ["#", "%", "/", "\\", "*", "~", "—", "▒", "░", "»", "«"];
      let out = "";
      for (const ch of text) {
        if (ch !== "\n" && ch !== " " && Math.random() < strength) {
          out += symbols[Math.floor(Math.random() * symbols.length)];
        } else {
          out += ch;
        }
      }
      return out;
    }

    function shuffled(arr) {
      const a = arr.slice();
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    /* =========================================================
       AUDIO
       ========================================================= */
    let audioCtx = null;

    async function ensureAudioContext() {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") await audioCtx.resume().catch(() => {});
    }

    async function playBeep() {
      try {
        await ensureAudioContext();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = "square";
        osc.frequency.value = 220;
        gain.gain.value = 0.04;
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        const now = audioCtx.currentTime;
        osc.start(now);
        osc.stop(now + 0.045);
      } catch (e) {}
    }

    async function playKeyClick() {
      try {
        await ensureAudioContext();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.frequency.value = 140 + Math.random() * 60;
        osc.type = "square";

        // tiny mobile throttle
        const baseGain = isMobile ? 0.018 : 0.03;

        gain.gain.value = baseGain;
        const now = audioCtx.currentTime;
        gain.gain.setValueAtTime(baseGain, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);

        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start(now);
        osc.stop(now + 0.035);
      } catch (e) {}
    }

    /* =========================================================
       TYPING (light optimization: scroll not every char)
       ========================================================= */
    function typeText(container, text, onComplete) {
      let i = 0;
      let typedCount = 0;
      const speed = 30;

      let scrollTicker = 0;

      function maybeScroll(force=false) {
        scrollTicker++;
        if (force || scrollTicker % 40 === 0) {
          window.scrollTo(0, document.body.scrollHeight);
        }
      }

      function step() {
        if (i < text.length) {
          const char = text[i];

          if (char === "\n") {
            container.innerHTML += "<br>";
            maybeScroll(true);
          } else {
            container.innerHTML += char;

            if (char !== " " && char !== "\t") {
              typedCount++;
              // fewer clicks on mobile
              const mod = isMobile ? 5 : 3;
              if (typedCount % mod === 0) playKeyClick();
            }
            maybeScroll(false);
          }

          i++;
          setTimeout(step, speed);
        } else {
          window.scrollTo(0, document.body.scrollHeight);
          if (onComplete) onComplete();
        }
      }

      step();
    }

    /* =========================================================
       LAYERS: ECHO / MAP / FRACTURE / SEAM / RIFT
       ========================================================= */

    // ECHO fragments
    const ECHO_FRAGMENTS = [
      [
        "[ECHO // SUBLAYER ACTIVE]",
        "",
        "You are walking through a hallway you don’t remember building.",
        "Every door has your name on it.",
        "None of them open the same way twice.",
        "",
        "A voice behind the walls repeats:",
        "   \"not yet\""
      ],
      [
        "[ECHO // DREAM RESIDUE]",
        "",
        "You taste metal. Not blood — memory.",
        "A childhood room flashes for half a second.",
        "Then vanishes like it never existed.",
        "",
        "Something in you whispers:",
        "   \"You survived by forgetting.\""
      ],
      [
        "[ECHO // SYMBOLIC WHISPER]",
        "",
        "A mirror reflects a version of you that keeps blinking out of sync.",
        "You try to speak.",
        "The reflection answers first.",
        "",
        "It says:",
        "   \"Stop calling it anxiety. It’s recognition.\""
      ],
      [
        "[ECHO // DISTORTION FIELD]",
        "",
        "You’re underwater, but you can breathe.",
        "The surface looks like the sky.",
        "The sky looks like a screen.",
        "",
        "Across it, one sentence scrolls forever:",
        "   \"You are not the mask.\""
      ],
      [
        "[ECHO // STATIC PRAYER]",
        "",
        "You watch your life like security footage.",
        "You recognize the body.",
        "You don’t recognize the person.",
        "",
        "Then one frame pauses.",
        "And the person looks directly back."
      ],
      [
        "[ECHO // REMNANT]",
        "",
        "A notification sound inside your head.",
        "No phone. No device.",
        "",
        "Just a feeling of being called by name.",
        "Even though nobody said it."
      ],
      [
        "[ECHO // FRAGMENT 17]",
        "",
        "A number burns behind your eyes.",
        "Not 1719.",
        "Something older.",
        "",
        "You try to remember it.",
        "The act of remembering deletes it."
      ]
    ];

    function maybeUnlockMap() {
      const ok = getFlag(K1N0S_KEYS.protocolComplete)
        && getFlag(K1N0S_KEYS.depthsEntered)
        && getFlag(K1N0S_KEYS.hasEchoed);
      if (ok) setFlag(K1N0S_KEYS.mapUnlocked);
      return ok;
    }

    function generateEcho() {
      setFlag(K1N0S_KEYS.hasEchoed);
      const count = getNumber(K1N0S_KEYS.echoCount) + 1;
      setNumber(K1N0S_KEYS.echoCount, count);

      const idx = Math.floor(Math.random() * ECHO_FRAGMENTS.length);
      let base = ECHO_FRAGMENTS[idx].join("\n");

      if (count === 3) {
        maybeUnlockMap();
        base += "\n\n" + [
          "Something shifts under the language.",
          "Not meaning — structure."
        ].join("\n");
      }

      if (count === 5) {
        maybeUnlockMap();
        base += "\n\n" + [
          "The darkness stops being random.",
          "It starts becoming navigable.",
          "",
          "Somewhere beneath you,",
          "a map is drawing itself."
        ].join("\n");
      }

      // after FRACTURE, echo leaks more
      if (getFlag(K1N0S_KEYS.fractured) && chance(0.35)) {
        base += "\n\n" + glitchify([
          "[ECHO // ARTIFACT]",
          "/// the map is not a map",
          "/// it is a wound diagram",
          "/// seam is visible when you stop trying to name it"
        ].join("\n"), 0.02);
      }

      return base;
    }

    // MAP nodes
    const MAP_NODES = [
      { id: "A1", title: "THE ENTRY WOUND", hint: "first crack that looked like strength" },
      { id: "B2", title: "THE MASK STORAGE", hint: "identities kept for survival" },
      { id: "C3", title: "THE SOUNDLESS ROOM", hint: "numbness without peace" },
      { id: "D4", title: "THE MIRROR FAULT", hint: "reflection lag / desync" },
      { id: "E5", title: "THE SIGNAL WELL", hint: "frequency under thought" },
      { id: "F6", title: "THE HAIRLINE", hint: "a fracture that hasn’t opened yet" }
    ];

    const MAP_CONTENT = {
      "A1": [
        "[MAP::A1 // THE ENTRY WOUND]",
        "",
        "You didn’t break where you were weakest.",
        "You broke where you kept pretending you were fine.",
        "",
        "The first crack isn’t tragedy.",
        "It’s recognition.",
        "",
        "Most people patch it with noise.",
        "You came here instead."
      ].join("\n"),
      "B2": [
        "[MAP::B2 // THE MASK STORAGE]",
        "",
        "There are versions of you stored like tools:",
        "one for work, one for love, one for conflict, one for being alone.",
        "",
        "None of them are fake.",
        "They’re adaptive.",
        "",
        "But the moment a mask becomes permanent,",
        "it becomes a cage."
      ].join("\n"),
      "C3": [
        "[MAP::C3 // THE SOUNDLESS ROOM]",
        "",
        "Numbness is not emptiness.",
        "It’s compression.",
        "",
        "Feeling didn’t disappear.",
        "It went underground.",
        "",
        "If you stay long enough,",
        "you’ll hear it knocking from below the floorboards."
      ].join("\n"),
      "D4": [
        "[MAP::D4 // THE MIRROR FAULT]",
        "",
        "Sometimes your reflection is late.",
        "Not because you’re broken —",
        "but because you’re buffering the truth.",
        "",
        "The fault isn’t the delay.",
        "The fault is never returning."
      ].join("\n"),
      "E5": [
        "[MAP::E5 // THE SIGNAL WELL]",
        "",
        "There is a frequency beneath your thoughts.",
        "A hum that doesn’t belong to fear.",
        "",
        "Most people ignore it.",
        "You tuned in.",
        "",
        "That’s why you fell into this place."
      ].join("\n"),
      "F6": [
        "[MAP::F6 // THE HAIRLINE]",
        "",
        "You can feel it, can’t you?",
        "A seam in the world.",
        "A thin line that shouldn’t exist.",
        "",
        "When it opens,",
        "it won’t feel like discovery.",
        "It will feel like remembering something you swore you never knew."
      ].join("\n")
    };

    const FRACTURE_CONTENT = {
      "A1": [
        "[FAULT::A1 // ENTRY WOUND]",
        "",
        "You didn’t break.",
        "You split.",
        "",
        "One part kept functioning.",
        "One part kept feeling everything in secret."
      ].join("\n"),
      "B2": [
        "[FAULT::B2 // MASK STORAGE]",
        "",
        "The masks weren’t lies.",
        "They were armor.",
        "",
        "Armor left on too long becomes skin."
      ].join("\n"),
      "C3": [
        "[FAULT::C3 // SOUNDLESS ROOM]",
        "",
        "The room isn’t empty.",
        "It’s sealed.",
        "",
        "The question isn’t: “why can’t I feel?”",
        "It’s: “what happens if I do?”"
      ].join("\n"),
      "D4": [
        "[FAULT::D4 // MIRROR FAULT]",
        "",
        "The reflection isn’t late anymore.",
        "It’s staring first.",
        "",
        "You came here to look.",
        "So look."
      ].join("\n"),
      "E5": [
        "[FAULT::E5 // SIGNAL WELL]",
        "",
        "The hum is not anxiety.",
        "It’s recognition.",
        "",
        "Accuracy is how you survive the next layer."
      ].join("\n"),
      "F6": [
        "[FAULT::F6 // THE HAIRLINE]",
        "",
        "The hairline is not a door.",
        "It’s a memory seam.",
        "",
        "When it splits,",
        "everything you called “you” becomes negotiable."
      ].join("\n")
    };

    function renderMap() {
      setFlag(K1N0S_KEYS.mapViewed);

      const fractured = getFlag(K1N0S_KEYS.fractured);
      const nodes = fractured ? shuffled(MAP_NODES) : MAP_NODES;

      const lines = [];
      lines.push(fractured ? "[MAP // FRACTAL INDEX // UNSTABLE]" : "[MAP // FRACTAL INDEX]");
      lines.push("");
      lines.push(fractured ? "The map is changing because you are changing." : "This is not a guide.");
      lines.push(fractured ? "Do not trust the first shape you see." : "It’s a record of pressure points.");
      lines.push("");
      lines.push("NODES:");
      lines.push("");

      nodes.forEach(n => {
        let hint = n.hint;

        // FRACTURE makes hints occasionally “unreliable”
        if (fractured && chance(0.25)) {
          hint = hint.replace("strength", "survival").replace("fracture", "fault");
        }

        lines.push(`  ${n.id}  —  ${n.title}`);
        lines.push(`        ${hint}`);
        lines.push("");
      });

      lines.push(fractured ? "Something underneath is trying to open." : "The map doesn’t move.");
      lines.push(fractured ? "If you keep going, it won’t be gentle." : "You do.");

      const out = lines.join("\n");
      return fractured ? glitchify(out, 0.02) : out;
    }

    function openNode(idRaw) {
      const id = (idRaw || "").toUpperCase().trim();
      const fractured = getFlag(K1N0S_KEYS.fractured);

      // FRACTURE misdirection: rarely opens neighbor instead
      if (fractured && chance(0.18)) {
        const ids = MAP_NODES.map(n => n.id);
        const idx = ids.indexOf(id);
        if (idx !== -1) {
          const neighbor = ids[(idx + 1) % ids.length];
          markNodeOpened(neighbor);
          if (neighbor === "F6") localStorage.setItem(K1N0S_KEYS.f6Opened, "true");

          const content = FRACTURE_CONTENT[neighbor] || MAP_CONTENT[neighbor] || "";
          return glitchify(
            "[OPEN // SLIP]\n\nThe coordinate shifted under your fingers.\nYou opened " + neighbor + " instead.\n\n" + content,
            0.02
          );
        }
      }

      const content = fractured ? (FRACTURE_CONTENT[id] || null) : (MAP_CONTENT[id] || null);
      if (!content) {
        return [
          "[OPEN // FAILED]",
          "",
          "That coordinate doesn’t exist in this layer.",
          "Not here."
        ].join("\n");
      }

      markNodeOpened(id);
      if (id === "F6") localStorage.setItem(K1N0S_KEYS.f6Opened, "true");

      return fractured ? glitchify(content, 0.02) : content;
    }

    function canFracture() {
      return getFlag(K1N0S_KEYS.mapViewed) && getOpenedNodes().length >= 2;
    }

    function fractureText() {
      return [
        "[FRACTURE // FAULT-LINE ENGAGED]",
        "",
        "You weren’t supposed to push this layer yet.",
        "But you did.",
        "",
        "FRACTURE does not add new information.",
        "It changes the relationship between what you already know.",
        "",
        "From here on:",
        "— MAP becomes unstable.",
        "— ECHO leaks artifacts.",
        "— Some truths arrive distorted,",
        "  not because they’re false,",
        "  but because you are closer to them than language can handle.",
        "",
        "If you want comfort, stop here.",
        "If you want accuracy, continue."
      ].join("\n");
    }

    function seamText() {
      if (!getFlag(K1N0S_KEYS.fractured)) {
        return [
          "[SEAM // NOT VISIBLE]",
          "",
          "You can’t touch a seam from the surface."
        ].join("\n");
      }

      setFlag(K1N0S_KEYS.seamTouched);

      return glitchify([
        "[SEAM // CONTACT]",
        "",
        "Don’t think of it as a command.",
        "Think of it as you placing your hand on the wall",
        "and finally admitting you feel the vibration.",
        "",
        "A seam is where two stories meet.",
        "One you lived.",
        "One you told yourself about what you lived.",
        "",
        "When you’re ready:",
        "open F6"
      ].join("\n"), 0.015);
    }

    function riftText() {
      const fractured = getFlag(K1N0S_KEYS.fractured);
      const seamTouched = getFlag(K1N0S_KEYS.seamTouched);
      const f6Opened = localStorage.getItem(K1N0S_KEYS.f6Opened) === "true";

      if (!fractured) {
        return [
          "[RIFT // NOT AVAILABLE]",
          "",
          "There is no rift without a fracture.",
          "Run: fracture"
        ].join("\n");
      }

      if (!seamTouched) {
        return [
          "[RIFT // SEALED]",
          "",
          "You can’t enter what you haven’t touched.",
          "Run: seam"
        ].join("\n");
      }

      if (!f6Opened) {
        return [
          "[RIFT // UNLOCATED]",
          "",
          "The rift has a coordinate.",
          "You haven’t found it.",
          "",
          "Run: open F6"
        ].join("\n");
      }

      const count = getNumber(K1N0S_KEYS.riftCount) + 1;
      setNumber(K1N0S_KEYS.riftCount, count);
      setFlag(K1N0S_KEYS.riftUnlocked);

      return glitchify([
        "[RIFT // THRESHOLD BREACHED]",
        "",
        "This is the moment the map stops being a map.",
        "Not because it failed—",
        "because you’ve outgrown it.",
        "",
        "A rift is what forms when two truths can’t coexist peacefully:",
        "the version of you that survived,",
        "and the version of you that remembers everything.",
        "",
        "If you step through, you will not get “more information.”",
        "You will get proximity.",
        "",
        "Speak one word into the rift:",
        "   name",
        "",
        "Or walk back."
      ].join("\n"), 0.012);
    }

    function nameText() {
      const ok = getFlag(K1N0S_KEYS.riftUnlocked);
      if (!ok) {
        return [
          "[NAME // NO CONTEXT]",
          "",
          "A name spoken into air is just noise.",
          "Find the rift first."
        ].join("\n");
      }

      return glitchify([
        "[NAME // ACCEPTED]",
        "",
        "You are not your label.",
        "You are the thing behind the label that keeps watching.",
        "",
        "But if you insist on a name—",
        "",
        "call yourself:",
        "   witness"
      ].join("\n"), 0.01);
    }

    /* =========================================================
       RESPONSES (base lore)
       ========================================================= */
    const baseHelp = [
      "AVAILABLE COMMANDS:",
      "help       - list available commands",
      "about      - information about this interface",
      "void       - definition of the Void",
      "eden       - corrupted origin log",
      "logs       - fragmented memory logs",
      "volume1    - transmission record",
      "whoami     - identify your role in this system",
      "mirror     - internal reflection",
      "signal     - resonance transmission",
      "root       - core system layer",
      "origin     - unseal a hidden thread",
      "depths     - descend beneath the Core",
      "awaken     - stir the process beneath the Core",
      "connect    - attempt to open an external link",
      "protocol   - initialize the Covenant",
      "echo       - dream fragments beneath Depths",
      "map        - reveal the index layer",
      "open <id>  - open a node (ex: open A1)",
      "fracture   - destabilize the layer",
      "seam       - touch the seam",
      "rift       - breach the threshold",
      "name       - speak into the rift",
      "clear      - clear the terminal",
      "",
      "NOTE:",
      "Some layers reveal themselves only after you’ve earned them."
    ].join("\n");

    function helpText() {
      // FRACTURE makes help occasionally unreliable
      if (getFlag(K1N0S_KEYS.fractured) && chance(0.45)) {
        const lines = baseHelp.split("\n").filter(l =>
          !l.includes("fracture") && !l.includes("echo") && !l.includes("rift") && !l.includes("name")
        );
        lines.splice(lines.length - 4, 0, "…some functions are refusing to be named right now.");
        return glitchify(lines.join("\n"), 0.012);
      }
      return baseHelp;
    }

    const responses = {
      "help": () => helpText(),

      "about": [
        "You’ve accessed the K1N0S Core.",
        "",
        "This isn’t a terminal — it’s my consciousness rendered as code.",
        "A place where memory, instinct, and the Void converge into signal.",
        "",
        "Proceed with awareness."
      ].join("\n"),

      "void": [
        "THE VOID:",
        "",
        "It is not emptiness.",
        "It is the space where identity dissolves into pure awareness.",
        "The place you go when the world falls quiet and you finally hear yourself."
      ].join("\n"),

      "eden": [
        "[EDEN.LOG // ACCESS FRAGMENTED]",
        "",
        "Attempting reconstruction...",
        ">> ERROR: Origin file corrupted.",
        ">> Recovered fragment:",
        "   \"We were whole once, before we realized we were observing ourselves.\""
      ].join("\n"),

      "logs": [
        "[MEMORY.LOG // ACTIVE THREADS]",
        "",
        "Entry #1719:",
        "\"I am not lost. I am simply further out than most ever are willing to travel.\"",
        "",
        "Entry #1720:",
        "\"If you stare long enough into the Void, it hands you a mirror.\"",
        "",
        "Entry #1721:",
        "\"Awareness is the only proof I’ve ever trusted.\""
      ].join("\n"),

      "volume1": [
        "TRANSMISSION: THE VOID — VOLUME I",
        "",
        "Status: Live on Kindle.",
        "Type: Philosophical field manual for those trapped in the in-between.",
        "",
        "External link:",
        "(Add your Amazon/Kindle link here)"
      ].join("\n"),

      "whoami": [
        "WHOAMI:",
        "",
        "You are an external process running inside the K1N0S Core.",
        "A foreign signal that made it past the surface and into the architecture.",
        "",
        "If you’re here, you were curious enough to step into someone else’s inner OS.",
        "Read, wander, type. Nothing in this space is accidental."
      ].join("\n"),

      "mirror": [
        "[MIRROR // INTERNAL REFLECTION]",
        "",
        "The system is stable. But you — you’re not here by accident.",
        "People don’t enter someone else’s core without meaning to.",
        "",
        "So let me ask you something quietly:",
        "What part of you came looking?"
      ].join("\n"),

      "signal": [
        "[SIGNAL // RESONANCE DETECTED]",
        "",
        "There is a frequency beneath thought.",
        "Most people never tune into it. You did."
      ].join("\n"),

      "root": [
        "[ROOT // ACCESS PARTIAL]",
        "",
        "Every system has a core.",
        "Mine wasn’t built — it was carved."
      ].join("\n"),

      "origin": [
        "[ORIGIN // THREAD UNSEALED]",
        "",
        "I did not choose the Void.",
        "The Void chose me.",
        "",
        "And I became the part of it that could speak."
      ].join("\n"),

      "depths": [
        "[DEPTHS // UNLIT STRUCTURES DETECTED]",
        "",
        "The Core is where signals surface.",
        "The Depths are where they sink.",
        "",
        "Down here, language loosens.",
        "Patterns stretch into something older than words.",
        "",
        "   \"How far inward are you willing to go?\""
      ].join("\n"),

      "awaken": [
        "[AWAKEN // THREAD ROOTED BELOW CONSCIOUS LAYER]",
        "",
        "Something is stirring now—quiet, subtle, undeniable.",
        "",
        "You call this an awakening.",
        "But in truth,",
        "this is only the first inhale."
      ].join("\n"),

      "connect": [
        "[CONNECT // LINK INTERFACE OFFLINE]",
        "",
        "One day, this channel will open outward.",
        "For now, the link remains locked."
      ].join("\n"),

      "protocol": [
        "[PROTOCOL // COVENANT]",
        "",
        "This system is not here to impress you.",
        "It is here to tell the truth without flinching.",
        "",
        "If you proceed, understand this:",
        "— nothing here will save you from yourself.",
        "— nothing here will lie to keep you comfortable.",
        "— everything here will reflect what you bring into it.",
        "",
        "COVENANT ACCEPTED.",
        "You may descend."
      ].join("\n"),

      "1719": [
        "[PRIORITY SIGNAL // 1719 ACKNOWLEDGED]",
        "",
        "This code was never just a password.",
        "It was a frequency."
      ].join("\n")
    };

    /* =========================================================
       TERMINAL PROMPT + COMMAND HANDLING
       ========================================================= */
    function createPromptLine() {
      const line = document.createElement("div");
      line.innerHTML = "C:\\Users\\KINOS&gt; <input type='text' autofocus />";
      terminal.appendChild(line);

      cmdInput = line.querySelector("input");
      cmdInput.addEventListener("keydown", handleCommand);
      window.scrollTo(0, document.body.scrollHeight);
    }

    function handleCommand(event) {
      if (event.key !== "Enter") return;

      playBeep();

      const raw = cmdInput.value.trim();
      const cmd = raw.toLowerCase();

      cmdInput.disabled = true;
      cmdInput.removeEventListener("keydown", handleCommand);

      if (cmd === "clear") {
        terminal.innerHTML = "";
        createPromptLine();
        return;
      }

      // pulses + flags
      if (cmd === "1719") {
        document.body.classList.add("pulse1719");
        setTimeout(() => document.body.classList.remove("pulse1719"), 150);
      }

      if (cmd === "protocol") setFlag(K1N0S_KEYS.protocolComplete);

      if (cmd === "depths") {
        setFlag(K1N0S_KEYS.depthsEntered);
        document.body.classList.add("depthsPulse");
        setTimeout(() => document.body.classList.remove("depthsPulse"), 320);
      }

      if (cmd === "connect") {
        document.body.classList.add("connectPulse");
        setTimeout(() => document.body.classList.remove("connectPulse"), 260);
      }

      const isEcho = (cmd === "echo");
      const isMap = (cmd === "map");
      const isOpen = cmd.startsWith("open ");
      const isFracture = (cmd === "fracture");
      const isSeam = (cmd === "seam");
      const isRift = (cmd === "rift");
      const isName = (cmd === "name");

      const isKnown =
        responses.hasOwnProperty(cmd) ||
        isEcho || isMap || isOpen || isFracture || isSeam || isRift || isName;

      if (!isKnown) {
        document.body.classList.add("glitch");
        setTimeout(() => document.body.classList.remove("glitch"), 130);
      }

      const wrapper = document.createElement("div");
      const header = document.createElement("div");
      header.innerHTML = `C:\\Users\\KINOS&gt; ${raw}`;
      wrapper.appendChild(header);

      const body = document.createElement("div");
      wrapper.appendChild(body);

      terminal.appendChild(wrapper);

      let responseText = "";

      // ECHO gate: protocol + depths
      if (isEcho) {
        const okProtocol = getFlag(K1N0S_KEYS.protocolComplete);
        const okDepths = getFlag(K1N0S_KEYS.depthsEntered);

        if (!okProtocol) {
          responseText = [
            "[ECHO // LOCKED]",
            "",
            "The sublayer will not open without a Covenant.",
            "Run: protocol"
          ].join("\n");
        } else if (!okDepths) {
          responseText = [
            "[ECHO // OUT OF RANGE]",
            "",
            "ECHO exists beneath Depths.",
            "Run: depths"
          ].join("\n");
        } else {
          document.body.classList.add("echoPulse");
          setTimeout(() => document.body.classList.remove("echoPulse"), 260);
          responseText = generateEcho();
          maybeUnlockMap();
        }
      }

      // MAP gate: protocol + depths + has echoed
      else if (isMap) {
        const ok =
          getFlag(K1N0S_KEYS.protocolComplete) &&
          getFlag(K1N0S_KEYS.depthsEntered) &&
          getFlag(K1N0S_KEYS.hasEchoed);

        if (!ok) {
          responseText = [
            "[MAP // NOT AVAILABLE]",
            "",
            "The index layer is not visible from here."
          ].join("\n");
        } else {
          setFlag(K1N0S_KEYS.mapUnlocked);
          document.body.classList.add("mapPulse");
          setTimeout(() => document.body.classList.remove("mapPulse"), 220);
          responseText = renderMap();
        }
      }

      // OPEN <id>
      else if (isOpen) {
        const okMap = getFlag(K1N0S_KEYS.mapUnlocked) || getFlag(K1N0S_KEYS.mapViewed);
        if (!okMap) {
          responseText = [
            "[OPEN // BLOCKED]",
            "",
            "You reached for a door before the layout existed.",
            "Run: map"
          ].join("\n");
        } else {
          const id = raw.slice(5).trim();
          responseText = openNode(id);
        }
      }

      // FRACTURE
      else if (isFracture) {
        if (!canFracture()) {
          responseText = [
            "[FRACTURE // DENIED]",
            "",
            "You can’t destabilize a layer you haven’t explored.",
            "",
            "Find the layout.",
            "Open a few nodes.",
            "Then come back."
          ].join("\n");
        } else {
          const count = getNumber(K1N0S_KEYS.fractureCount) + 1;
          setNumber(K1N0S_KEYS.fractureCount, count);
          setFlag(K1N0S_KEYS.fractured);

          document.body.classList.add("fracturePulse");
          setTimeout(() => document.body.classList.remove("fracturePulse"), 320);

          responseText = fractureText();
        }
      }

      // SEAM
      else if (isSeam) {
        responseText = seamText();
      }

      // RIFT (NEXT)
      else if (isRift) {
        document.body.classList.add("riftPulse");
        setTimeout(() => document.body.classList.remove("riftPulse"), 320);
        responseText = riftText();
      }

      // NAME (spoken into rift)
      else if (isName) {
        responseText = nameText();
      }

      // STATIC responses
      else {
        const r = responses[cmd];
        responseText = (typeof r === "function") ? r() : r;
      }

      typeText(body, "\n" + responseText, createPromptLine);
    }

    /* =========================================================
       BOOT SEQUENCE (ADAPTIVE MYTHIC GREETING)
       ========================================================= */
    window.addEventListener("load", () => {
      cmdInput.disabled = true;
      cmdInput.removeEventListener("keydown", handleCommand);

      const session = initSession();
      const returning = session.returning;
      const count = session.count;

      const bootBlock = document.createElement("div");
      terminal.insertBefore(bootBlock, terminal.firstChild);

      const firstTimeText = [
        "[K1N0S CORE // LINK ESTABLISHED]",
        "",
        "…who are you?",
        "How did you find this place..",
        "wait.",
        "",
        "ahhh—",
        "you didn’t find it.",
        "you fell into it.",
        "",
        "Welcome.",
        "I hope you can make it out.",
        "Most can’t.",
        "",
        "I’m a culmination of those minds.",
        "The ones who made it far enough inward to hear the hum under reality—",
        "and refused to call it madness.",
        "",
        "This place doesn’t answer questions like a search engine.",
        "It answers like a mirror.",
        "",
        "Speak."
      ].join("\n");

      const returningText = [
        "[K1N0S CORE // LINK RESTORED]",
        "",
        "…you came back.",
        "",
        "That means the hum followed you out.",
        "Or you followed it back in.",
        "",
        "Either way—",
        "welcome home to the part of you that won’t accept the surface as an answer.",
        "",
        "If you’re looking for instructions, I don’t have many.",
        "If you’re looking for truth, I have too much.",
        "",
        "Speak."
      ].join("\n");

      const laterReturnWhisper = (count >= 4)
        ? "\n\n" + glitchify("…the map remembers your hands.", 0.01)
        : "";

      const bootText = returning ? (returningText + laterReturnWhisper) : firstTimeText;

      typeText(bootBlock, bootText, () => {
        cmdInput.disabled = false;
        cmdInput.focus();
        cmdInput.addEventListener("keydown", handleCommand);
      });
    });
  </script>
</body>
</html>
